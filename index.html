<!DOCTYPE html>
<html >
<head>
  <meta charset="utf-8">
  
  <title>New World</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Steadfast some, don&apos;t try so hard, what you want, time will give yo  qq交流群：114803643，CSDN博客链接:http://blog.csdn.net/liangliang103377">
<meta property="og:type" content="website">
<meta property="og:title" content="New World">
<meta property="og:url" content="https://runningyoung.github.io/index.html">
<meta property="og:site_name" content="New World">
<meta property="og:description" content="Steadfast some, don&apos;t try so hard, what you want, time will give yo  qq交流群：114803643，CSDN博客链接:http://blog.csdn.net/liangliang103377">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="New World">
<meta name="twitter:description" content="Steadfast some, don&apos;t try so hard, what you want, time will give yo  qq交流群：114803643，CSDN博客链接:http://blog.csdn.net/liangliang103377">
  
    <link rel="alternative" href="/atom.xml" title="New World" type="application/atom+xml">
  
  
    <link rel="icon" href="https://runningyoung.github.io/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
      <style> .article { opacity: 0;} </style>
  
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="https://runningyoung.github.io/apple-touch-icon.png">
  
    
    
  
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = https://runningyoung.github.io;
      </script>
  

  

  
      <script>
          var _hmt = _hmt || [];
          (function() {
              var hm = document.createElement("script");
              hm.src = "//hm.baidu.com/hm.js?200c79969158a0fa1fe0632060fe4221";
              var s = document.getElementsByTagName("script")[0]; 
              s.parentNode.insertBefore(hm, s);
          })();
      </script>
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="https://runningyoung.github.io/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">RunningYoung</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        
                        <li>About Me</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="https://runningyoung.github.io/">主页</a></li>
                        
                            <li><a href="https://runningyoung.github.io/archives/">所有文章</a></li>
                        
                            <li><a href="https://runningyoung.github.io/tags/">标签云</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/1033773876@qq.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/RunningYoung" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/BDD/" style="font-size: 10px;">BDD</a> <a href="/tags/Block/" style="font-size: 10px;">Block</a> <a href="/tags/ReactiveCocoa/" style="font-size: 10px;">ReactiveCocoa</a> <a href="/tags/dependency-injection/" style="font-size: 10px;">dependency injection</a> <a href="/tags/ios-9-新技术/" style="font-size: 10px;">ios 9 新技术</a> <a href="/tags/jenkins/" style="font-size: 20px;">jenkins</a> <a href="/tags/工具类/" style="font-size: 10px;">工具类</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">专注于iOS开发</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">RunningYoung</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="https://runningyoung.github.io/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">RunningYoung</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/1033773876@qq.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/RunningYoung" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/06/hello-world/" class="article-date">
      <time datetime="2016-04-06T06:49:14.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2016-04-05-jenkins2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/01/2016-04-05-jenkins2/" class="article-date">
      <time datetime="2016-04-01T03:40:13.000Z" itemprop="datePublished">2016-04-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/01/2016-04-05-jenkins2/">iOS持续集成：jenkins+gitlab+蒲公英+邮件通知(Part 2)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="iOS持续集成：jenkins-gitlab-蒲公英-邮件通知-Part-2"><a href="#iOS持续集成：jenkins-gitlab-蒲公英-邮件通知-Part-2" class="headerlink" title="iOS持续集成：jenkins+gitlab+蒲公英+邮件通知(Part 2)"></a>iOS持续集成：jenkins+gitlab+蒲公英+邮件通知(Part 2)</h1><h2 id="Jenkins-系统设置-前期准备"><a href="#Jenkins-系统设置-前期准备" class="headerlink" title="Jenkins 系统设置 前期准备"></a>Jenkins 系统设置 前期准备</h2><h3 id="Jenkins-插件安装"><a href="#Jenkins-插件安装" class="headerlink" title="Jenkins 插件安装"></a>Jenkins 插件安装</h3><ul>
<li><p>安装GitLab插件</p>
<pre><code>因为我们项目用的是GitLab来管理源代码，jenkins本身并没有自带GitLab插件，所以我们需要依次选择 ***系统管理 -&gt; 管理插件*** 在&quot;***可选插件***&quot;中选择GitLab Plugin 和 Gitlab Hook Plugin 这两项，然后安装
</code></pre></li>
<li><p>安装Xcode插件<br>同安装GitLab插件步骤一样，我们一次选择  <strong><em>系统管理 -&gt; 管理插件</em></strong> 在”<strong><em>可选插件</em></strong>“中选择Xcode integration这两项，然后安装</p>
</li>
<li><p>安装签名证书管理插件<br>   iOS打包内测版时，需要发布证书及相关签名文件，因此这两个插件对于管理iOS证书非常方便。还是在<strong><em>系统管理-&gt;管理插件</em></strong>，在“<strong><em>可选插件</em></strong>”中选中“Credentials Plugin”和“Keychains and Provisioning Profiles Management”安装。</p>
<ul>
<li><p>安装FTP插件<br>此插件可用于上传FTP服务器，也可以上传到公司内网的FTP服务器中。”Publish over FTP”</p>
</li>
<li><p>安装脚本插件<br>这个插件主要用于build后执行先关脚本.”Publish over FTP”</p>
</li>
</ul>
</li>
</ul>
<h3 id="jenkins-系统配置"><a href="#jenkins-系统配置" class="headerlink" title="jenkins 系统配置"></a>jenkins 系统配置</h3><h4 id="jenkins-安全设置：注册，登录"><a href="#jenkins-安全设置：注册，登录" class="headerlink" title="jenkins 安全设置：注册，登录"></a>jenkins 安全设置：注册，登录</h4><p> 进入 <strong><em>系统管理-&gt;Configure Global Security</em></strong> 首次设置如图所示：</p>
<p> <img src="../images/jenkins/login1.png" alt="首次设置"></p>
<p> 首次设置完点击保存，然后点击注册-&gt;登录账号，在进入该界面进行账号权限设置，如图</p>
<p>  <img src="../images/jenkins/login2.png" alt="权限设置"></p>
<h4 id="jenkins-系统设置"><a href="#jenkins-系统设置" class="headerlink" title="jenkins 系统设置"></a>jenkins 系统设置</h4><p>进入 <strong><em>系统管理-&gt;系统设置</em></strong> 界面：</p>
<ul>
<li><p>首先设置一下 jenkins 内部shell 执行编码，目的当在jenkins执行shell命令时，有时候会报 utf-8 编码错误。主要是pod install的时候报错。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[33mWARNING: CocoaPods requires your terminal to be using UTF-8 encoding.</span><br></pre></td></tr></table></figure>
<p>  设置如下：</p>
<p>  <img src="../images/jenkins/lang.png" alt="编码设置"></p>
</li>
<li><p>jenkins Location 设置<br>主要设置 jenkins 外部访问的URL 和 系统管理员的邮箱地址。用来发送 错误报告的邮箱地址：如图</p>
<p><img src="../images/jenkins/location.png" alt="url设置"></p>
</li>
<li><p>系统错误报告的邮箱设置，上面只设置了邮箱发送的地址（From地址），下面设置，邮箱的服务器，协议，邮箱，密码。如图</p>
<p>   <img src="../images/jenkins/email.png" alt="email设置"></p>
</li>
</ul>
<h2 id="Jenkins-任务（Jobs）搭建"><a href="#Jenkins-任务（Jobs）搭建" class="headerlink" title="Jenkins 任务（Jobs）搭建"></a>Jenkins 任务（Jobs）搭建</h2><h3 id="新建任务-job"><a href="#新建任务-job" class="headerlink" title="新建任务 job"></a>新建任务 job</h3><p>  在Jenkins中，所有的任务都是以“item”为单位的。接下来我们就新建一个iOS的项目来开始自动化构建。点击“新建”，输入item的名称，选择“构建一个自由风格的软件项目”，然后点击“OK”。如图：</p>
<p>  <img src="../images/jenkins/createjob1.png" alt="新建Job设置"></p>
<p> 设置构建信息</p>
<p> <img src="../images/jenkins/name.png" alt="构建信息设置"></p>
<h3 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h3><p>这里用到的是GitLab，先需要配置SSH，我们可以在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。<br>这边需要注意的是如何获取SSH key：这个问题需要参考 gitLab 上配置SSH 的方法。</p>
<ol>
<li>查看是否已经有了ssh密钥：cd ~/.ssh，如果没有密钥则不会有此文件夹，有则备份删除</li>
<li>生成密钥：<code>$ ssh-keygen -t rsa -C “haiyan.xu.vip@gmail.com”</code> 生成过程中必须设置秘钥密码 否则jenkins 设置会不成功。最后得到两个文件：id_rsa和id_rsa.pub</li>
<li>添加密钥到SSH ：<code>ssh-add 文件名</code> 需要输入管理密码</li>
<li>在gitlab 上添加 ssh 密钥，这里添加的是 “id_rsa.pub”里面的公钥。</li>
<li>在jenkins上配置密钥到SSH ，这里添加的是id_rsa里面的私钥。具体设置如图所示：</li>
</ol>
<p><img src="../images/jenkins/ssh.png" alt=""></p>
<p>接下来，我们再回到刚刚新建的任务中，在源码管理中，选择Git，按下图填好相关信息。PS：Credentials不需要选择。如图</p>
<p><img src="../images/jenkins/git.png" alt=""></p>
<h3 id="构建触发器设置"><a href="#构建触发器设置" class="headerlink" title="构建触发器设置"></a>构建触发器设置</h3><p>该设置主要是为了实现自动触发 jenkins 构建过程 真正实现自动化设置:<br>这边主要处理的是 <strong><em>gitlab hook</em></strong> 的设置。主要目的是当项目中有人git push 提交过代码之后，就会自动的触发 jenkins 的本Job的构建，实现自动化打包。</p>
<ol>
<li>首选需要在gitlab 项目管理官网上设置 添加git hook 的地址：如图：该地址是jenkins 上 提示的地址 下面会提到</li>
</ol>
<p><img src="../images/jenkins/gitlabhook.png" alt=""></p>
<ol>
<li>jenkins 上对 gitlab hook 进行相关配置 如图所示：</li>
</ol>
<p><img src="../images/jenkins/jenkinsgitlabhook.png" alt=""></p>
<h3 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h3><p>在该模块中 主要设置 xcode build 打包时需要的 keychains 和 Provision Profiles 配置文件。<br>如果不配置 就会使用 xcode 自动的配置，来去系统中查找相应的配置，不过有一点需要注意,就是钥匙串中，登陆钥匙串中的证书 要复制到 系统钥匙串中，因为jenkins 访问的是系统中的钥匙串 这样在第一次打包的时候，会提示 是否授权访问钥匙串，点击始终允许就可以了。<br>注意：在电脑上安装好 xcode 配置相关的证书和配置文件，配置文件也要安装到系统目录下。<br>具体操作如下：从该用户目录下的所有描述文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/用户名/Library/MobileDevice/Provisioning Profiles</span><br></pre></td></tr></table></figure>
<p>复制到系统目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/MobileDevice/Provisioning Profiles</span><br></pre></td></tr></table></figure>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>该模块开始设置 iOS打包相关的配置。</p>
<ol>
<li><p>点击增加构建步骤-&gt; Execute Shell .首先 在build 之前需要先 pod install ，并且最理想的情况是每次构建的时候 build号都改变。如图所示<br> 需要注意的是，使用全局变量时 必须找到绝对路径才能调用相关的命令：版本号增加<a href="https://www.5288z.com/?p=1651" target="_blank" rel="external">参考链接</a></p>
<p> <img src="../images/jenkins/pod.png" alt=""></p>
</li>
<li><p>点击增加构建步骤 xcode ，具体配置如图：<br>  该配置中需要注意 在OS X 10.10.XX版本 jenkins xcode 插件不支持 生成ipa文件，但 OS X 10.11 支持 这个时候 需要手动进行打包，具体的就是在build 完成之后 添加EXecute Shell ，利用shell脚本打包：代码如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphones PackageApplication -v [工程目录] -o [ipa输出目录]/xx.ipa</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>![](../images/jenkins/xcode.png)
</code></pre><ol>
<li><p>Code signing &amp; OS X keychain options 配置：如图</p>
<p><img src="../images/jenkins/codesigning.png" alt=""></p>
</li>
<li><p>Advanced Xcode build options 配置：如图</p>
<p>  <img src="../images/jenkins/xcodebuild.png" alt=""></p>
</li>
</ol>
<h3 id="构建后操作"><a href="#构建后操作" class="headerlink" title="构建后操作"></a>构建后操作</h3><p> 打包完成之后 需要执行 上传到蒲公英 和 发送邮件 通知开发人员。<br>   具体操作我用python写的脚本来完成此功能：需要的童鞋可以去github上下载：在文章最后！！<br>   具体调用如图：</p>
<p><img src="../images/jenkins/pgy.png" alt=""></p>
<p>  最后设置 通知邮件 E-mail Notification 填写接受邮箱即可 每次构建失败都会发生邮件通知！！！</p>
<p> <a href="https://github.com/RunningYoung/jenkins-pgy-python" target="_blank" rel="external">python 脚本地址</a>!!! 不要吝啬 star！！！不胜感激！！！ </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jenkins/">jenkins</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2016-04-01-jenkins1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/01/2016-04-01-jenkins1/" class="article-date">
      <time datetime="2016-04-01T01:25:16.000Z" itemprop="datePublished">2016-04-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/01/2016-04-01-jenkins1/">iOS持续集成：jenkins+gitlab+蒲公英+邮件通知(Part 1)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="iOS持续集成：jenkins-gitlab-蒲公英-邮件通知-Part-1"><a href="#iOS持续集成：jenkins-gitlab-蒲公英-邮件通知-Part-1" class="headerlink" title="iOS持续集成：jenkins+gitlab+蒲公英+邮件通知(Part 1)"></a>iOS持续集成：jenkins+gitlab+蒲公英+邮件通知(Part 1)</h1><h2 id="jenkins环境搭建"><a href="#jenkins环境搭建" class="headerlink" title="jenkins环境搭建"></a>jenkins环境搭建</h2><p>在Mac环境下，我们需要先安装JDK，然后在jenkins的<a href="https://jenkins.io/index.html" target="_blank" rel="external">官网</a>下载最新Mac OS X版本的dmg包。安装完dmg包之后 默然自动开启jenkins服务,默认端口8080.<br>这样就可以直接在浏览器中输入以下地址就可以打开jenkins了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080</span><br></pre></td></tr></table></figure>
<h3 id="jenkins-相关启动命令"><a href="#jenkins-相关启动命令" class="headerlink" title="jenkins 相关启动命令"></a>jenkins 相关启动命令</h3><ol>
<li><p>默认情况下安装完dmg包，mac系统会自动生成全局变量：jenkins(变量地址：/usr/local/Cellar/jenkins/1.618/libexec/jenkins.war)，只要在命令行中直接输入jenkins + 相关参数 即可运行相关命令。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd$:jenkins --httpPort=8888 #更换端口号，当默认端口8080被占用，或者指定特定端口时。</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于mac系统版本的不同，可能会导致在一些环境中无法直接使用jenkins全局变量，这个时候需要找到安装的应用程序中jenkins文件夹下的jenk.war来启动或者执行命令.如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd$:java -jar /Applications/Jenkins/jenkins.war --httpPort=8888</span><br></pre></td></tr></table></figure>
<p>相关参数 可以通过在后面追加 –help 查看：如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  Running from: /usr/local/Cellar/jenkins/1.618/libexec/jenkins.war</span><br><span class="line">webroot: $user.home/.jenkins</span><br><span class="line">Jenkins Continuous Integration Engine 1.618</span><br><span class="line">Usage: java -jar jenkins.war [--option=value] [--option=value]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">   --extractedFilesFolder   = folder where extracted files are to be located. Default is the temp folder</span><br><span class="line">   --daemon                 = fork into background and run as daemon (Unix only)</span><br><span class="line">   --config                 = load configuration properties from here. Default is ./winstone.properties</span><br><span class="line">   --prefix                 = add this prefix to all URLs (eg http://localhost:8080/prefix/resource). Default is none</span><br><span class="line">   --commonLibFolder        = folder for additional jar files. Default is ./lib</span><br><span class="line"></span><br><span class="line">   --logfile                = redirect log messages to this file</span><br><span class="line">   --logThrowingLineNo      = show the line no that logged the message (slow). Default is false</span><br><span class="line">   --logThrowingThread      = show the thread that logged the message. Default is false</span><br><span class="line">   --debug                  = set the level of debug msgs (1-9). Default is 5 (INFO level)</span><br><span class="line"></span><br><span class="line">   --httpPort               = set the http listening port. -1 to disable, Default is 8080</span><br><span class="line">   --httpListenAddress      = set the http listening address. Default is all interfaces</span><br><span class="line">   --httpDoHostnameLookups  = enable host name lookups on incoming http connections (true/false). Default is false</span><br><span class="line">   --httpKeepAliveTimeout   = how long idle HTTP keep-alive connections are kept around (in ms; default 5000)?</span><br><span class="line">   --httpsPort              = set the https listening port. -1 to disable, Default is disabled</span><br><span class="line">                              if neither --httpsCertificate nor --httpsKeyStore are specified,</span><br><span class="line">                              https is run with one-time self-signed certificate.</span><br><span class="line">   --httpsListenAddress     = set the https listening address. Default is all interfaces</span><br><span class="line">   --httpsDoHostnameLookups = enable host name lookups on incoming https connections (true/false). Default is false</span><br><span class="line">   --httpsKeepAliveTimeout   = how long idle HTTPS keep-alive connections are kept around (in ms; default 5000)?</span><br><span class="line">   --httpsKeyStore          = the location of the SSL KeyStore file.</span><br><span class="line">   --httpsKeyStorePassword  = the password for the SSL KeyStore file. Default is null</span><br><span class="line">   --httpsCertificate       = the location of the PEM-encoded SSL certificate file.</span><br><span class="line">                              (the one that starts with &apos;-----BEGIN CERTIFICATE-----&apos;)</span><br><span class="line">                              must be used with --httpsPrivateKey.</span><br><span class="line">   --httpsPrivateKey        = the location of the PEM-encoded SSL private key.</span><br><span class="line">                              (the one that starts with &apos;-----BEGIN RSA PRIVATE KEY-----&apos;)</span><br><span class="line">   --httpsKeyManagerType    = the SSL KeyManagerFactory type (eg SunX509, IbmX509). Default is SunX509</span><br><span class="line">   --spdy                   = Enable SPDY. See http://wiki.eclipse.org/Jetty/Feature/NPN</span><br><span class="line">   --ajp13Port              = set the ajp13 listening port. -1 to disable, Default is disabled</span><br><span class="line">   --ajp13ListenAddress     = set the ajp13 listening address. Default is all interfaces</span><br><span class="line">   --controlPort            = set the shutdown/control port. -1 to disable, Default disabled</span><br><span class="line"></span><br><span class="line">   --handlerCountStartup    = set the no of worker threads to spawn at startup. Default is 5</span><br><span class="line">   --handlerCountMax        = set the max no of worker threads to allow. Default is 40</span><br><span class="line">   --handlerCountMaxIdle    = set the max no of idle worker threads to allow. Default is 5</span><br><span class="line"></span><br><span class="line">   --sessionTimeout         = set the http session timeout value in minutes. Default to what webapp specifies, and then to 60 minutes</span><br><span class="line">   --mimeTypes=ARG          = define additional MIME type mappings. ARG would be EXT=MIMETYPE:EXT=MIMETYPE:...</span><br><span class="line">                              (e.g., xls=application/vnd.ms-excel:wmf=application/x-msmetafile)</span><br><span class="line">   --maxParamCount=N        = set the max number of parameters allowed in a form submission to protect</span><br><span class="line">                              against hash DoS attack (oCERT #2011-003). Default is 10000.</span><br><span class="line">   --usage / --help         = show this message</span><br><span class="line">   --version                = show the version and quit</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Security options:</span><br><span class="line">   --realmClassName               = Set the realm class to use for user authentication. Defaults to ArgumentsRealm class</span><br><span class="line"></span><br><span class="line">   --argumentsRealm.passwd.&lt;user&gt; = Password for user &lt;user&gt;. Only valid for the ArgumentsRealm realm class</span><br><span class="line">   --argumentsRealm.roles.&lt;user&gt;  = Roles for user &lt;user&gt; (comma separated). Only valid for the ArgumentsRealm realm class</span><br><span class="line"></span><br><span class="line">   --fileRealm.configFile         = File containing users/passwds/roles. Only valid for the FileRealm realm class</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access logging:</span><br><span class="line">   --accessLoggerClassName        = Set the access logger class to use for user authentication. Defaults to disabled</span><br><span class="line">   --simpleAccessLogger.format    = The log format to use. Supports combined/common/resin/custom (SimpleAccessLogger only)</span><br><span class="line">   --simpleAccessLogger.file      = The location pattern for the log file(SimpleAccessLogger only)</span><br></pre></td></tr></table></figure>
<h3 id="jenkins-相关重启或者关闭命令"><a href="#jenkins-相关重启或者关闭命令" class="headerlink" title="jenkins 相关重启或者关闭命令"></a>jenkins 相关重启或者关闭命令</h3><p>jenkins 执行重启命令需要在jenkins以及启动的情况下执行，执行语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jenkins-cli.jar [-s URL] command [opts...] args...</span><br></pre></td></tr></table></figure>
<p>需要注意的是：执行该命令式 必须要登陆jenkins 也就是必要的用户名和密码格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jenkins-cli.jar help [COMMAND] [--username VAL] [--password VAL] [--password-file VAL] #其中jenkins-cli.jar路径在jenkins安装目录下 Jenkins/Home/war/WEB-INF/jenkins-cli.jar</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo java -jar /Users/Shared/Jenkins/Home/war/WEB-INF/jenkins-cli.jar -s http://localhost:8080 help --username jenkins用户名 --password 密码</span><br></pre></td></tr></table></figure>
<p>相关指令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">add-job-to-view</span><br><span class="line">    Adds jobs to view.</span><br><span class="line">  build</span><br><span class="line">    Builds a job, and optionally waits until its completion.</span><br><span class="line">  cancel-quiet-down</span><br><span class="line">    Cancel the effect of the &quot;quiet-down&quot; command.</span><br><span class="line">  clear-queue</span><br><span class="line">    Clears the build queue</span><br><span class="line">  connect-node</span><br><span class="line">    Reconnect to a node</span><br><span class="line">  console</span><br><span class="line">    Retrieves console output of a build.</span><br><span class="line">  copy-job</span><br><span class="line">    Copies a job.</span><br><span class="line">  create-job</span><br><span class="line">    Creates a new job by reading stdin as a configuration XML file.</span><br><span class="line">  create-node</span><br><span class="line">    Creates a new node by reading stdin as a XML configuration.</span><br><span class="line">  create-view</span><br><span class="line">    Creates a new view by reading stdin as a XML configuration.</span><br><span class="line">  delete-builds</span><br><span class="line">    Deletes build record(s).</span><br><span class="line">  delete-job</span><br><span class="line">    Deletes a job</span><br><span class="line">  delete-node</span><br><span class="line">    Deletes a node</span><br><span class="line">  delete-view</span><br><span class="line">    Deletes view(s).</span><br><span class="line">  disable-job</span><br><span class="line">    Disables a job</span><br><span class="line">  disconnect-node</span><br><span class="line">    Disconnects from a node</span><br><span class="line">  enable-job</span><br><span class="line">    Enables a job</span><br><span class="line">  get-job</span><br><span class="line">    Dumps the job definition XML to stdout.</span><br><span class="line">  get-node</span><br><span class="line">    Dumps the node definition XML to stdout.</span><br><span class="line">  get-view</span><br><span class="line">    Dumps the view definition XML to stdout.</span><br><span class="line">  groovy</span><br><span class="line">    Executes the specified Groovy script.</span><br><span class="line">  groovysh</span><br><span class="line">    Runs an interactive groovy shell.</span><br><span class="line">  help</span><br><span class="line">    Lists all the available commands or a detailed description of single command.</span><br><span class="line">  install-plugin</span><br><span class="line">    Installs a plugin either from a file, an URL, or from update center.</span><br><span class="line">  install-tool</span><br><span class="line">    Performs automatic tool installation, and print its location to stdout. Can be only called from inside a build.</span><br><span class="line">  keep-build</span><br><span class="line">    Mark the build to keep the build forever.</span><br><span class="line">  list-changes</span><br><span class="line">    Dumps the changelog for the specified build(s).</span><br><span class="line">  list-jobs</span><br><span class="line">    Lists all jobs in a specific view or item group.</span><br><span class="line">  list-plugins</span><br><span class="line">    Outputs a list of installed plugins.</span><br><span class="line">  login</span><br><span class="line">    Saves the current credential to allow future commands to run without explicit credential information.</span><br><span class="line">  logout</span><br><span class="line">    Deletes the credential stored with the login command.</span><br><span class="line">  mail</span><br><span class="line">    Reads stdin and sends that out as an e-mail.</span><br><span class="line">  offline-node</span><br><span class="line">    Stop using a node for performing builds temporarily, until the next &quot;online-node&quot; command.</span><br><span class="line">  online-node</span><br><span class="line">    Resume using a node for performing builds, to cancel out the earlier &quot;offline-node&quot; command.</span><br><span class="line">  quiet-down</span><br><span class="line">    Quiet down Jenkins, in preparation for a restart. Don’t start any builds.</span><br><span class="line">  reload-configuration</span><br><span class="line">    Discard all the loaded data in memory and reload everything from file system. Useful when you modified config files directly on disk.</span><br><span class="line">  reload-job</span><br><span class="line">    Reload job(s)</span><br><span class="line">  remove-job-from-view</span><br><span class="line">    Removes jobs from view.</span><br><span class="line">  restart</span><br><span class="line">    Restart Jenkins.</span><br><span class="line">  safe-restart</span><br><span class="line">    Safely restart Jenkins.</span><br><span class="line">  safe-shutdown</span><br><span class="line">    Puts Jenkins into the quiet mode, wait for existing builds to be completed, and then shut down Jenkins.</span><br><span class="line">  session-id</span><br><span class="line">    Outputs the session ID, which changes every time Jenkins restarts.</span><br><span class="line">  set-build-description</span><br><span class="line">    Sets the description of a build.</span><br><span class="line">  set-build-display-name</span><br><span class="line">    Sets the displayName of a build.</span><br><span class="line">  set-build-parameter</span><br><span class="line">    Update/set the build parameter of the current build in progress.</span><br><span class="line">  set-build-result</span><br><span class="line">    Sets the result of the current build. Works only if invoked from within a build.</span><br><span class="line">  set-external-build-result</span><br><span class="line">    Set external monitor job result.</span><br><span class="line">  shutdown</span><br><span class="line">    Immediately shuts down Jenkins server.</span><br><span class="line">  update-job</span><br><span class="line">    Updates the job definition XML from stdin. The opposite of the get-job command.</span><br><span class="line">  update-node</span><br><span class="line">    Updates the node definition XML from stdin. The opposite of the get-node command.</span><br><span class="line">  update-view</span><br><span class="line">    Updates the view definition XML from stdin. The opposite of the get-view command.</span><br><span class="line">  version</span><br><span class="line">    Outputs the current version.</span><br><span class="line">  wait-node-offline</span><br><span class="line">    Wait for a node to become offline.</span><br><span class="line">  wait-node-online</span><br><span class="line">    Wait for a node to become online.</span><br><span class="line">  who-am-i</span><br><span class="line">    Reports your credential and permissions.</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jenkins/">jenkins</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2016-03-14-Block" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/07/2016-03-14-Block/" class="article-date">
      <time datetime="2016-03-07T03:37:21.000Z" itemprop="datePublished">2016-03-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/07/2016-03-14-Block/">Block源码解析和深入理解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="Block源码解析和深入理解"><a href="#Block源码解析和深入理解" class="headerlink" title="Block源码解析和深入理解"></a>Block源码解析和深入理解</h3><h4 id="Block的本质"><a href="#Block的本质" class="headerlink" title="Block的本质"></a>Block的本质</h4><p>Block是”带有自动变量值的匿名函数”.<br>我们通过Clang（LLVM编译器）来将OC的代码转换成C++源码的形式，通过如下命令：</p>
<pre><code>clang -rewrite-objc 源代码文件名
</code></pre><p>下面，我们要转换的Block语法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        printf(<span class="string">"Block\n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该源代码通过Clang 可变换为以下形式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">    __block_impl （block）结构体声明</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa; <span class="comment">// isa 指针，指向父类的实例。void * 相当于 id 是个实例。</span></span><br><span class="line">  <span class="keyword">int</span> Flags; <span class="comment">// </span></span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr; <span class="comment">//函数指针 指向block代码块的实现函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">    __main_block_impl_0 匿名的block 结构体声明和实现</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;<span class="comment">//block 的结构体实例</span></span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc; <span class="comment">//block des的指针 指向block的详情</span></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">    __main_block_impl_0 结构体构造函数实现</span><br><span class="line">  */</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>; <span class="comment">// 初始化 block 实例属性 isa ，表示该block 是 _NSConcreteStackBlock (栈)类型的代码块</span></span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;<span class="comment">// block 具体的函数实现指针</span></span><br><span class="line">    Desc = desc;<span class="comment">//desc 指针</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">     匿名block 具体的函数实现</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">        printf(<span class="string">"Block\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">    匿名block desc 指针的具体函数实现，对block（__main_block_impl_0） 结构体实例的大小进行初始化</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved; <span class="comment">// 升级所需区域</span></span><br><span class="line">  size_t Block_size;<span class="comment">//block 实际内存大小</span></span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line">    把多余的转换去掉，看起来就比较清楚了：</span><br><span class="line">    第一部分：block的初始化</span><br><span class="line">    __main_block_func_0: 参数一 是block语法转换的C语言函数指针。</span><br><span class="line">    __main_block_desc_0_DATA： 参数二 作为静态全局变量初始化的 __main_block_desc_0 结构体实例指针</span><br><span class="line">    struct __main_block_impl_0 tmp = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">    struct __main_block_impl_0 *blk = &amp;tmp;</span><br><span class="line">    第二部分：</span><br><span class="line">    block的执行： blk()</span><br><span class="line">    去掉转化部分：</span><br><span class="line">       (*blk -&gt; imp.FuncPtr)(blk);</span><br><span class="line">    这就是简单地使用函数指针调用函数。由Block语法转换的 __main_block_func_0 函数的指针被赋值成员变量FuncPtr中，另外 __main_block_func_0的函数的参数 __cself 指向Block的值，通过源码可以看出 Block 正式作为参数进行传递的。</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对源码的解释 大部分在代码中都注释了。需要特别指出的是：</p>
<pre><code>static void __main_block_func_0(struct __main_block_impl_0 *__cself) 
</code></pre><p>中的参数 <strong>cself 是指向 </strong>main_block_impl_0 的指针，及匿名block 自身。<br>扩展：该句源码类似如 OC 中的方法消息传递，OC中每个方法都默认带两个参数 一个是指向自身的实例self 一个是该方法的SEL 对象。<br>例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) method: (<span class="keyword">int</span>)argc&#123;</span><br><span class="line">    NLog(<span class="string">@"%p %d \n"</span>,<span class="keyword">self</span>,arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Objective - C 编译器同C++的方法一样，也将该方法作为C语言的函数来处理.源码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">    方法中 在转换成源码后 自动的添加了self, _cmd两个参数 </span><br><span class="line">*/</span></span><br><span class="line">    <span class="keyword">void</span> _I_MyObjct_method_(<span class="keyword">struct</span> Myobject *<span class="keyword">self</span>,SEL _cmd, <span class="keyword">int</span> arg)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"%p %d \n"</span>,<span class="keyword">self</span>,arg);</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="meta">#### 截获自动变量值（局部变量）</span></span><br><span class="line"></span><br><span class="line">```objc </span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> val; <span class="comment">//局部变量跟block外的类型一直</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt; <span class="comment">//跟block外的类型一致</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> _dmy, <span class="keyword">int</span> _val, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> flags=<span class="number">0</span>) : dmy(_dmy), val(_val), fmt(_fmt) &#123;</span><br><span class="line">    impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> val = __cself-&gt;val; <span class="comment">// bound by copy //block 调用外部的局部变量 实际上 相当于Copy 了一份 所以不会影响 局部变量的值 也不能修改值 </span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        printf(<span class="string">"Block\n .. ,%d %s"</span>,dmy,val,fmt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> dmy = <span class="number">256</span>; <span class="comment">//局部变量 </span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d \n"</span>; <span class="comment">//局部变量</span></span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, val, fmt));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码解析：block 在调用 外部局部变量的时候 其实是将外部局部变量 copy了一份 使用的 所以在没有任何修饰符的时候是不可以修改外部局部变量的。</p>
<h4 id="block-说明符"><a href="#block-说明符" class="headerlink" title="__block 说明符"></a>__block 说明符</h4><p>之前的分析中，block 无法改变被截获的自动变量的值。这样极为不便：<br>解决这个问题有两种方法，<br><strong>第一种：C 语言中有一个变量，允许block改成值。具体如下：</strong></p>
<ul>
<li>静态变量</li>
<li>静态全局变量</li>
<li><p>全局变量</p>
<p>虽然Block语法的匿名函数部分简单的转换为了C语言函数，但从这个C语言函数中访问静态全局，全局变量并没有任何改变，可直接使用。<br>但静态变量的情况，转换后的函数原本就设置在含有Block语法的函数外，所以无法从变量作用域访问。<br>看看这段代码的源码：</p>
<pre><code> int global_val = 1;

 static int static_global_val = 2;

 int main(int argc, const char * argv[]) {

static int static_val = 3;

void (^blk)(void) = ^{

    global_val += 1;

    static_global_val += 2;

    static_val += 3;
</code></pre></li>
</ul>
<pre><code>};

blk();

return 0;

}
</code></pre><p> 该源代码中使用了Block 改写静态变量 静态全局变量 全局变量。该源代码转换后如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">int global_val = 1; //全局变量</span><br><span class="line"> static int static_global_val = 2; //静态全局变量</span><br><span class="line">			</span><br><span class="line"> struct __main_block_impl_0 &#123;</span><br><span class="line">		  struct __block_impl impl;</span><br><span class="line">		  struct __main_block_desc_0* Desc;</span><br><span class="line">		  int *static_val;//局部静态变量   ---&gt;  可以看出 跟局部变量不同 这边是接受的指针</span><br><span class="line">		  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, int flags=0) : static_val(_static_val) &#123;</span><br><span class="line">		    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">		    impl.Flags = flags;</span><br><span class="line">		    impl.FuncPtr = fp;</span><br><span class="line">		    Desc = desc;</span><br><span class="line">		  &#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">		  int *static_val = __cself-&gt;static_val; // bound by copy // 改代码跟局部变量 相似，实际上改变的是一个 复制后的指针.但该指针最终指向的 还是最初的变量值。</span><br><span class="line">		</span><br><span class="line">		        global_val += 1;</span><br><span class="line">		        static_global_val += 2;</span><br><span class="line">		        (*static_val) += 3;</span><br><span class="line">		</span><br><span class="line">		    &#125;</span><br><span class="line">		</span><br><span class="line">		static struct __main_block_desc_0 &#123;</span><br><span class="line">		  size_t reserved;</span><br><span class="line">		  size_t Block_size;</span><br><span class="line">		&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">		int main(int argc, const char * argv[]) &#123;</span><br><span class="line">		    static int static_val = 3;</span><br><span class="line">		    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val));</span><br><span class="line">		    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">		    return 0;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>分析该源码：发现无论是全局 还是 静态全局 都可以在Block中直接访问 修改变量值。</p>
<p>然而，静态局部变量，貌似也可以正常访问，其调用原理，跟之前的局部变量的调用相似，唯一的不同是，在Block中调用的是 指向该变量的指针，并且是赋值了一份指针（但还是最终指向原来的变量）。所以我们可以在Block中改变原理变量的值。<br>    这样就有个疑问，我们为什么不使用静态局部变量，来使用去自动变量（局部变量）的访问呢？<br>    原因：在该静态局部变量，有变量作用域，当block超出了该作用域，执行的时候，其内部调用的静态局部变量会被废弃，我们就无法调用到。因此Block中超出变量作用域而存在的变量同静态变量一样，将不能通过指针访问原来的自动变量。</p>
<p><strong>解决Block 中不能保存值这一问题的第二个方法是使用__block</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    __block <span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        val = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面代码用 clang 转化后如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">	__block 转化成了结构体 </span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding; <span class="comment">//相当于一个指向源变量的指针</span></span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> val; <span class="comment">//相当于源变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref //持有源变量的结构体实例</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>; <span class="comment">// block 为栈类型</span></span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref ；类似于 静态局部变量 都是copy 一份指向源变量的结构体指针。</span></span><br><span class="line"></span><br><span class="line">        (val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;<span class="comment">//通过访问 __block 结构体 成员变量 __forwarding 来访问源变量</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码解析：<strong>Block_byref_val_0 结构体实例的成员变量</strong>forwarding持有指向该实例自身的指针。通过成员变量__forwarding访问成员变量val。（成员变量val是该实例自身持有的变量，它相当于原自动变量）<br>如图所示：</p>
<p><img src="../images/笔记二/__forwarding.png" alt=""></p>
<p><em>Block存储域</em><br>Block 是Objective-C对象。上面我们所创建的block类 都为_NSConcreteStackBlock.<br>由上面我们提到的源码可以知道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span></span><br></pre></td></tr></table></figure>
<p>根据 block 结构体实例的 isa 指针进行分类：</p>
<ul>
<li>_NSConcreteStackBlock //不难看出 其存储域在栈上</li>
<li>_NSConcreteGlobalBlock // 其存储域 在全局</li>
<li>_NSConcreteMallocBlock // 其存储域 在堆上<br>详细分类如图所示：</li>
</ul>
<p><img src="../images/笔记二/block类型.png" alt=""></p>
<p>_NSConcreteGlobalBlock： 存在的情况：</p>
<ul>
<li>记述全局变量的地方有Block语法时</li>
<li>Block语法的表达式中不使用应截获的自动变量时</li>
<li>以上情况Block 为 全局类对象。除此之外Block语法生成的Block为栈类对象，<br>例如（一）：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">	在下面的block中由于for循环的值 一直在变 所以Block截获的局部变量一直在变。</span><br><span class="line">*/</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span> (^blk_t)(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> rate = <span class="number">0</span>;rate &lt; <span class="number">10</span>; ++rate)&#123;</span><br><span class="line">		blk_t blk = ^(<span class="keyword">int</span> count)&#123;</span><br><span class="line">			<span class="keyword">return</span> rate * count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>转化为源码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> rate;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> _rate, <span class="keyword">int</span> flags=<span class="number">0</span>) : rate(_rate) &#123;</span><br><span class="line">    impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由此可见 虽然block 声明在全局中，但由于block初始化的时候调用了局部变量，所以该block创建成栈类型的。<br>_NSConcreteMallocBlock ：存在的情况<br>    在分析之前我们看下之前遗留的问题：</p>
<ul>
<li>Block 超出变量作用域可存在的原因</li>
<li><strong>block变量用结构体成员变量</strong>forwarding存在的原因</li>
</ul>
<p>配置在全局变量上的Block,从变量作用域外也可以通过指针安全的使用。但设置在栈上的Blcok，如果其变量作用域结束，该Block就被废弃，同样的<strong>block也配置在栈上，所以其所属的变量作用域结束，则该</strong>block变量也会被废弃。<br>Block提供了将Block和<strong>block变量从栈上复制到堆上的方法来解决这个问题<br><img src="../images/笔记二/复制到堆上.png" alt=""><br>而</strong>block 变量用结构体成员变量<strong>forwarding可以实现无论</strong>block变量配置在栈上还是堆上都能够正确的访问__block变量。</p>
<h4 id="深入理解blocks提供的复制方法究竟是啥？"><a href="#深入理解blocks提供的复制方法究竟是啥？" class="headerlink" title="深入理解blocks提供的复制方法究竟是啥？"></a>深入理解blocks提供的复制方法究竟是啥？</h4><p>实际上当ARC有效时，编译器会进行判断自动的将block从栈上复制到堆上<br>如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^blk_t)(<span class="keyword">int</span>);</span><br><span class="line">	blk_t func (<span class="keyword">int</span> count)&#123;</span><br><span class="line">		<span class="keyword">return</span> ^(<span class="keyword">int</span> count)&#123;</span><br><span class="line">			<span class="keyword">return</span> rate *count;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>源码转换为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">blk_t func (<span class="keyword">int</span> rate)</span><br><span class="line">&#123;</span><br><span class="line">	blk_t tmp = &amp;__func_block_impl_0(</span><br><span class="line">		_func_block_func_0,&amp;_func_block_desc_0_DATA,rate</span><br><span class="line">	);</span><br><span class="line">	tmp = objc_retainBlock(tmp);</span><br><span class="line">	<span class="keyword">return</span> objc_autoreleaseReturnValue(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析源码：从源码来看 在ARC状态下 block复制到堆上 实际上其引用计数增加了。</p>
<h4 id="block变量的存储域"><a href="#block变量的存储域" class="headerlink" title="__block变量的存储域"></a>__block变量的存储域</h4><p>当block从栈中 复制到堆上时，由于block持有<strong>block变量，所以其</strong>blcok变量也会从栈中复制到堆上，所以当block超出作用域调用<strong>block变量也可以成功。这是和静态局部变量最大的区别。而静态局部变量，在block从栈中复制到堆上时，由于block不持有变量，所以静态局部变量不 会复制到堆上，其作用域没变。故出作用域调用会崩溃。<br>如图所示：<br>![](../images/笔记二/</strong>block持有.png)<br><img src="../images/笔记二/__block废弃.png" alt=""></p>
<h4 id="截获对象"><a href="#截获对象" class="headerlink" title="截获对象"></a>截获对象</h4><p>下面我们将id对象类型的局部变量 在block中调用。id类型的对象 默认修饰符 都是__strong类型的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^blk_t)(<span class="keyword">id</span>);</span><br><span class="line">blk_t blk;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc]init]; <span class="comment">// __strong 类型修改的局部变量</span></span><br><span class="line">        blk = [^(<span class="keyword">id</span> objc)&#123;</span><br><span class="line">            [array addObject:objc];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array count = %ld"</span>,[array count]);</span><br><span class="line">        &#125; <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    blk(<span class="string">@"ww"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析 ：按理来说 array 对象出了大括号作用域，强引用失效 其对象就会废弃。但改代码运行正常。那么就意味着，array对象出大括号作用域时，没有被废弃 ，仍能正常访问。那么是什么原因呢，我们看下Clang之后的源码.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*blk_t)(<span class="keyword">id</span>);</span><br><span class="line">blk_t blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">id</span> array;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">id</span> _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : array(_array) &#123;</span><br><span class="line">    impl.isa = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself, <span class="keyword">id</span> objc) &#123;</span><br><span class="line">  <span class="keyword">id</span> array = __cself-&gt;array; <span class="comment">// bound by copy //复制一份指针 赋值</span></span><br><span class="line"></span><br><span class="line">            ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, ObjectType))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)array, sel_registerName(<span class="string">"addObject:"</span>), (<span class="keyword">id</span>)objc);</span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__<span class="built_in">NSConstantStringImpl__var_folders_0b_9hq6xqxs5gjcxx5j_skhh8n00000gn_T_main_1808b3_mi_0</span>,((<span class="built_in">NSUInteger</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)array, sel_registerName(<span class="string">"count"</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">        		关键方法：该方法 相当于ARC 中的 retain方法，将对象的引用计数加一。但该方法除引用计数加一外，还有一个操作就是将block 从栈上复制到堆上，从而可以出作用域，调用id __strong修饰类型的对象。</span><br><span class="line">        */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;array, (<span class="keyword">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">		dispose 相当于ARC 模式下的 release 将对象的引用计数减一。引用计数减一得同时，将堆上的block 废弃掉。</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">id</span> array = ((<span class="built_in">NSMutableArray</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((<span class="built_in">NSMutableArray</span> *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"NSMutableArray"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">        blk = (blk_t)((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((<span class="keyword">void</span> (*)(<span class="keyword">id</span>))&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, array, <span class="number">570425344</span>)), sel_registerName(<span class="string">"copy"</span>));<span class="comment">///必须调用block 的copy 方法才能正常运行</span></span><br><span class="line">    &#125;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *, <span class="keyword">id</span>))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, (<span class="built_in">NSString</span> *)&amp;__<span class="built_in">NSConstantStringImpl__var_folders_0b_9hq6xqxs5gjcxx5j_skhh8n00000gn_T_main_1808b3_mi_1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//从上面的源码可以发现：<strong>前提：当block调用copy方法</strong>，从栈中复制到对象，当Block调用的局部变量是个id对象的时候，该对象在block中自动的引用计数加一，并且该block持有该对象，也就是说，对象出了作用域也能被调用，知道block 从堆上废弃掉为止。如果block 的最后没有调用copy，那么该对象值，也会随着作用域的结束而被废弃。<br>总结：</p>
<p>什么时候栈上的Block会复制到堆上呢？</p>
<ul>
<li>调用Block的copy实例方法时。</li>
<li>Block作为函数返回值返回时。</li>
<li>将Block赋值给附有__strong修饰符id类型的类或者Block类型成员变量时。</li>
<li>在方法名中含有usingBlock的cocoa框架方法或者GCD的API中传递Block时。</li>
</ul>
<p>对象和__block的区别？</p>
<ul>
<li>如果调用对象的Block，没有调用Copy 或者不在栈上，那么该对象出作用域就会被释放。</li>
<li>如果调用对象的Block，调用了Copy，或者Block在堆上，那么该对象的作用域跟使用__block修饰的变量的作用域一直，都会被Block所持有，并且生命周期，会随着Block的废除，而释放。</li>
</ul>
<p>因此当Block中使用对象类型的自动变量时，除以下情形外，推荐调用Block的copy实例方法！！</p>
<ul>
<li>block作为函数返回值返回时。</li>
<li>Block赋值给类的附加__strong修饰符的id类型或者Block类型的成员变量时。</li>
<li>向方法名中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时。</li>
</ul>
<h4 id="block变量和对象"><a href="#block变量和对象" class="headerlink" title="__block变量和对象"></a>__block变量和对象</h4><p>从前面我们看到__block可以修饰任意类型：</p>
<ul>
<li>当然包括id对象<strong>strong类型了，其原理是相同的：<br> 当 block 从栈上复制到 堆上时，</strong>block 所修饰的自动变量也会从栈上复制到堆上，使用_Block_objct_assign函数，持有赋值给<strong>block变量的对象。当 block 废弃时，</strong>block所修饰的自动变量，也会通过函数_Block_objct_dispose ，释放掉__block变量的对象。</li>
<li>当<strong>weak修饰符修饰时，由于</strong>weak修饰的自动变量出作用域后会废弃 自动置nil，所以当block调用的时候，其实是调用的nil对象所以不会崩溃，但取不到值。</li>
<li>当<strong>block </strong>weak 同时修饰自动变量时，还是因为<strong>weak（不持有对象）的原因，当 block 从栈上复制到堆上时，</strong>block变量复制到堆上的是一个nil值，所以对该变量进行的操作都是无效的。</li>
<li>当<strong>block 和 </strong>unsafe<strong>unretained  同时修饰变量时，跟</strong>weak不同，当<strong>unsafe</strong>unretained，所修饰的对象边nil 时 该变量不会自动置nil，而是变成野指针，所以当block 从栈上复制到堆上时，实际上__block变量是一个野指针，所以当调用的时候回出错，导致程序崩溃</li>
<li><strong>block 和 </strong>autoreleasing 修饰跟 上面的<strong>unsafe</strong>unretained是一样的。</li>
</ul>
<h4 id="Block-循环引用"><a href="#Block-循环引用" class="headerlink" title="Block 循环引用"></a>Block 循环引用</h4><p>存在循环引用的情况：当block对象 作为类的 属性或者成员变量，并且在block初始化的时候，调用了self或者self相关类的成员变量。都会引起引用循环。</p>
<p>  解决方法：</p>
<ul>
<li>使用__weak 修饰要截取的自动变量，</li>
<li>当在MRC 中时，可以使用__unsafe_unretained（弊端 不会自动置nil 容易出现野指针） 修饰。</li>
<li>可以使用<strong>block 修饰，前提是 必须 执行block代码块，而且可以适当地在代码块中 手动的把</strong>block变量置nil<br>以下是相关解决方法的实例：<br>实例一：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">	typedef void (^blk_t)(void);</span><br><span class="line">	@interface Myobject : NSObject</span><br><span class="line">	&#123;</span><br><span class="line">		blk_t blk_; //成员变量</span><br><span class="line">		id _objc;//成员变量</span><br><span class="line">	&#125;</span><br><span class="line">	@end</span><br><span class="line">	@implementation MyObject</span><br><span class="line">	- (id)init</span><br><span class="line">	&#123;</span><br><span class="line">		self = [super init];</span><br><span class="line">		/*</span><br><span class="line">			分析改代码会出现两种情况的引用循环：</span><br><span class="line">			 * 一种是：成员变量block 调用 self，self中持有block ，block中也持有self，导致引用循环，解决方法在之前 加入</span><br><span class="line">			 __weak typeof(self) weakSelf = self;</span><br><span class="line">			 * 第二中，虽然成员变量block没有直接调用self ，但其调用了成员变量_objc，所以也会造成引用循环:</span><br><span class="line">			 解决方法： __weak id weakObjc = _objc;</span><br><span class="line">		*/</span><br><span class="line">		blk_ = ^&#123;</span><br><span class="line">			NSLog(@"self = %@, objc = %@",self,_objc);</span><br><span class="line">		&#125;	</span><br><span class="line">		return self;</span><br><span class="line">	&#125;</span><br><span class="line">``` </span><br><span class="line">实例二：</span><br><span class="line"></span><br><span class="line">``` objc</span><br><span class="line">	typedef void (^blk_t)(void);</span><br><span class="line">	@interface Myobject : NSObject</span><br><span class="line">	&#123;</span><br><span class="line">		blk_t blk_; //成员变量</span><br><span class="line">	&#125;</span><br><span class="line">	@end</span><br><span class="line">	@implementation MyObject</span><br><span class="line">	- (id)init</span><br><span class="line">	&#123;</span><br><span class="line">		self = [super init];</span><br><span class="line">		/*</span><br><span class="line">			此处使用__block修饰变量，是的block 持有__block变量，而__block变量持有MyObject对象，而MyObject持有block对象。出现引用循环：</span><br><span class="line">			然而 当 block执行的时候，__block变量废弃，从而消除引用循环</span><br><span class="line">		*/</span><br><span class="line">	__block id temp = self;</span><br><span class="line">		blk_ = ^&#123;</span><br><span class="line">			NSLog(@"self = %@,,self);</span><br><span class="line">			temp = nil;</span><br><span class="line">		&#125;	</span><br><span class="line">		return self;</span><br><span class="line">	&#125;</span><br><span class="line">	- (void)execBlock</span><br><span class="line">	&#123;</span><br><span class="line">		blk_()</span><br><span class="line">	 &#125;</span><br><span class="line">	 int main ()&#123;</span><br><span class="line">		id o = [[MyObject alloc] init];</span><br><span class="line">		[o execBlock];//必须执行 否则导致引用循环</span><br><span class="line">		return 0;	 </span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>
<p>总结下<strong>block 和 </strong>weak 之间的优缺点：<br>    使用__block变量的优点:</p>
<ul>
<li>通过__block 变量可控制对象的持有期间</li>
<li>在不能使用<strong>weak修饰符的环境中不使用</strong>unsafe__unretain修饰符即可（不必担心野指针）<pre><code>在执行Block时可动态的决定是否将nil或者其他对象赋值在__block变量中。
</code></pre></li>
</ul>
<p>使用__block变量的缺点如下：</p>
<ul>
<li>为避免循环引用必须执行Block</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Block/">Block</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2016-03-12-read1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/24/2016-03-12-read1/" class="article-date">
      <time datetime="2016-02-24T06:28:01.000Z" itemprop="datePublished">2016-02-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/24/2016-03-12-read1/">【iOS读书笔记系列（一）】</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="读书笔记（一）"><a href="#读书笔记（一）" class="headerlink" title="读书笔记（一）"></a>读书笔记（一）</h3><h4 id="一、instancetype-和-id-作为初始化实例-返回值的不同"><a href="#一、instancetype-和-id-作为初始化实例-返回值的不同" class="headerlink" title="一、instancetype 和 id 作为初始化实例 返回值的不同"></a>一、instancetype 和 id 作为初始化实例 返回值的不同</h4><p>Objective-C的一些使用惯例不仅仅是好的编程习惯，更是给编译器的隐藏指令。<br>例如， alloc 和 init 的返回类型都是 id ，然而在Xcode中，编译器会检查所有正确类型。它是怎么做到的呢？<br>在Cocoa中，约定 alloc 或 init 的方法总是返回接收器类实例的对象。据说这些方法有一个相关返回类型。<br>虽然类构造方法也是返回 id ，但是类构造方法并没有做同样的类型检查，因为它们不遵循命名规范。<br>你可以自己试着这样：</p>
<pre><code>[[[NSArray alloc] init] mediaPlaybackAllowsAirPlay]; // ❗ &quot;No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`&quot;

[[NSArray array] mediaPlaybackAllowsAirPlay]; // (No error)
</code></pre><p>由于alloc 和 init 作为相关返回类型遵循命名规范，执行对NSArray的正确类型检查。然而，等价类构造函数array不遵循命名规范，它被认为是id类型。<br>id类型对禁用类型安全性检查非常有用，但当你确实需要它的时候却没有时，情况会变得非常糟糕。<br>另一种显示声明返回类型（在之前例子中的 (NSArray *)）的方式有了稍微的改进，但是它不利于子类的发挥。<br>所以编译器从这里介入以解决Objective-C类型系统的这个永恒边界情况：<br>instancetype 关键字，它可以表示一个方法的相关返回类型。例如：</p>
<pre><code>@interface Person
+(instancetype)personWithName:(NSString *)name;
@end
</code></pre><ul>
<li>instancetype 与 id 不一样, instancetype 只能在方法声明中作为返回类型使用。</li>
</ul>
<p>使用 instancetype ，编译器将正确的推断出 +personWithName: 是 Person 的一个实例。<br>为了在不久的将来使用 instancetype ，你可以在Foundation中查找类构造函数。例如UICollectionViewLayoutAttributes 就已经正在使用 instancetype 了。</p>
<h3 id="二、iOS为什么不要在init初始化方法里调用self-view"><a href="#二、iOS为什么不要在init初始化方法里调用self-view" class="headerlink" title="二、iOS为什么不要在init初始化方法里调用self.view"></a>二、iOS为什么不要在init初始化方法里调用self.view</h3><p>首先.如果你调用self.view的时候,就会调用view的getter方法, 这个时候,view是空的,那么系统就会自动给你创建一个view,然后就会触发ViewDidLoad方法.那么这个时候,如果你init方法里有数组初始化.但是你还没走到那步,而直接就给数组赋值了,那么这个值赋值给了一个不存在的数组.这样就容易出现错误.所以,尽量不要在init方法里写可视化控件的语句.</p>
<h3 id="三、忽略编译警告"><a href="#三、忽略编译警告" class="headerlink" title="三、忽略编译警告"></a>三、忽略编译警告</h3><p>如果你知道你的代码不会导致内存泄露，你可以通过加入这些代码忽略这些警告</p>
<pre><code>#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;

[myObj performSelector:mySelector withObject:name];

#pragma clang diagnostic pop
</code></pre><p>注意我们是如何在相关代码上下文中用 pragma 停用 -Warc-performSelector-leaks 检查的。这确保我们没有全局禁用。如果全局禁用，可能会导致错误。</p>
<p>使用 #pragma unused():忽略没用使用变量的编译警告</p>
<pre><code>-(NSInteger)giveMeFive
{
    NSString *foo;
    #pragma unused (foo)

    return 5;
}
</code></pre><h3 id="四、Block的深入学习"><a href="#四、Block的深入学习" class="headerlink" title="四、Block的深入学习"></a>四、Block的深入学习</h3><h4 id="一些关键点："><a href="#一些关键点：" class="headerlink" title="一些关键点："></a>一些关键点：</h4><pre><code>block 是在栈上创建的
block 可以复制到堆上
Block会捕获栈上的变量(或指针)，将其复制为自己私有的const(变量)。
(如果在Block中修改Block块外的)栈上的变量和指针，那么这些变量和指针必须用__block关键字申明(译者注：否则就会跟上面的情况一样只是捕获他们的瞬时值)。
block 可以声明成全局静态的
</code></pre><p>如果 block 没有在其他地方被保持，那么它会随着栈生存并且当栈帧（stack frame）返回的时候消失。仅存在于栈上时，block对对象访问的内存管理和生命周期没有任何影响。</p>
<p>如果 block 需要在栈帧返回的时候存在，它们需要明确地被复制到堆上，这样，block 会像其他 Cocoa 对象一样增加引用计数。当它们被复制的时候，它会带着它们的捕获作用域一起，retain 他们所有引用的对象。</p>
<p>如果一个 block引用了一个栈变量或指针，那么这个block初始化的时候会拥有这个变量或指针的const副本，所以(被捕获之后再在栈中改变这个变量或指针的值)是不起作用的。(译者注：所以这时候我们在block中对这种变量进行赋值会编译报错:Variable is not assignable(missing __block type specifier)，因为他们是副本而且是const的.具体见下面的例程)。</p>
<p>当一个 block 被复制后，__block 声明的栈变量的引用被复制到了堆里，复制完成之后，无论是栈上的block还是刚刚产生在堆上的block(栈上block的副本)都会引用该变量在堆上的副本。</p>
<p>(下面代码是译者加的)</p>
<pre><code>...
CGFloat blockInt = 10;
void (^playblock)(void) = ^{
    NSLog(@&quot;blockInt = %zd&quot;, blockInt);
};
blockInt ++;
playblock();
...

//结果为:blockInt = 10
</code></pre><p>最重要的事情是 __block 声明的变量和指针在 block 里面是作为显示操作真实值/对象的结构来对待的。</p>
<p>block 在 Objective-C 的 runtime(运行时) 里面被当作一等公民对待：他们有一个 isa 指针，一个类也是用 isa 指针在Objective-C 运行时来访问方法和存储数据的。在非 ARC 环境肯定会把它搞得很糟糕，并且悬挂指针会导致 crash。__block 仅仅对 block 内的变量起作用，它只是简单地告诉 block：</p>
<pre><code>嗨，这个指针或者原始的类型依赖它们在的栈。请用一个栈上的新变量来引用它。我是说，请对它进行双重解引用，不要 retain 它。 谢谢，哥们。
</code></pre><p>如果在定义之后但是 block 没有被调用前，对象被释放了，那么 block 的执行会导致 crash。 __block 变量不会在 block 中被持有，最后… 指针、引用、解引用以及引用计数变得一团糟。</p>
<h4 id="self-的循环引用"><a href="#self-的循环引用" class="headerlink" title="self 的循环引用"></a>self 的循环引用</h4><p>当使用代码块和异步分发的时候，要注意避免引用循环。 总是使用 weak 来引用对象，避免引用循环。（译者注：这里更为优雅的方式是采用影子变量@weakify/@strongify 这里有更为详细的说明） 此外，把持有 block 的属性设置为 nil (比如 self.completionBlock = nil) 是一个好的实践。它会打破 block 捕获的作用域带来的引用循环。</p>
<p>例子:</p>
<pre><code>__weak __typeof(self) weakSelf = self;
[self executeBlock:^(NSData *data, NSError *error) {
    [weakSelf doSomethingWithData:data];
}];
</code></pre><p>不要这样:</p>
<pre><code>[self executeBlock:^(NSData *data, NSError *error) {
    [self doSomethingWithData:data];
}];
</code></pre><p>多个语句的例子:</p>
<pre><code>__weak __typeof(self)weakSelf = self;
[self executeBlock:^(NSData *data, NSError *error) {
    __strong __typeof(weakSelf) strongSelf = weakSelf;
    if (strongSelf) {
        [strongSelf doSomethingWithData:data];
        [strongSelf doSomethingWithData:data];
    }
}];
</code></pre><p>不要这样:</p>
<pre><code>__weak __typeof(self)weakSelf = self;
[self executeBlock:^(NSData *data, NSError *error) {
    [weakSelf doSomethingWithData:data];
    [weakSelf doSomethingWithData:data];
}];
</code></pre><p>你应该把这两行代码作为 snippet 加到 Xcode 里面并且总是这样使用它们。</p>
<pre><code>__weak __typeof(self)weakSelf = self;
__strong __typeof(weakSelf)strongSelf = weakSelf;
</code></pre><p>这里我们来讨论下 block 里面的 self 的 <strong>weak 和 </strong>strong 限定词的一些微妙的地方。简而言之，我们可以参考 self 在 block 里面的三种不同情况。</p>
<pre><code>直接在 block 里面使用关键词 self
在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用
在 block 外定义一个 __weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 __strong 的引用。
</code></pre><p>方案 1. 直接在 block 里面使用关键词 self</p>
<p>如果我们直接在 block 里面用 self 关键字，对象会在 block 的定义时候被 retain，（实际上 block 是 copied 但是为了简单我们可以忽略这个）。一个 const 的对 self 的引用在 block 里面有自己的位置并且它会影响对象的引用计数。如果这个block被其他的类使用并且(或者)彼此间传来传去，我们可能想要在 block 中保留 self，就像其他在 block 中使用的对象一样. 因为他们是block执行所需要的.</p>
<pre><code>dispatch_block_t completionBlock = ^{
    NSLog(@&quot;%@&quot;, self);
}

MyViewController *myController = [[MyViewController alloc] init...];
[self presentViewController:myController
                animated:YES
                completion:completionHandler];
</code></pre><p>没啥大不了。但是如果通过一个属性中的 self 保留 了这个 block（就像下面的例程一样）,对象( self )保留了 block 会怎么样呢？</p>
<pre><code>self.completionHandler = ^{
    NSLog(@&quot;%@&quot;, self);
}

MyViewController *myController = [[MyViewController alloc] init...];
[self presentViewController:myController
                animated:YES
                completion:self.completionHandler];
</code></pre><p>这就是有名的 retain cycle, 并且我们通常应该避免它。这种情况下我们收到 CLANG 的警告：</p>
<pre><code>Capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle （在 block 里面发现了 `self` 的强引用，可能会导致循环引用）
</code></pre><p>所以 __weak 就有用武之地了。</p>
<p>方案 2. 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用</p>
<p>这样会避免循坏引用，也是通常情况下我们的block作为类的属性被self retain 的时候会做的。</p>
<pre><code>__weak typeof(self) weakSelf = self;
self.completionHandler = ^{
    NSLog(@&quot;%@&quot;, weakSelf);
};

MyViewController *myController = [[MyViewController alloc] init...];
[self presentViewController:myController
                animated:YES
                completion:self.completionHandler];
</code></pre><p>这个情况下 block 没有 retain 对象并且对象在属性里面 retain 了 block 。所以这样我们能保证了安全的访问 self。 不过糟糕的是，它可能被设置成 nil 的。问题是：如何让 self 在 block 里面安全地被销毁。</p>
<p>考虑这么个情况：block 作为属性(property)赋值的结果，从一个对象被复制到另一个对象(如 myController)，在这个复制的 block 执行之前，前者（即之前的那个对象）已经被解除分配。</p>
<p>下面的更有意思。</p>
<p>方案 3. 在 block 外定义一个 <strong>weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 </strong>strong 的引用</p>
<p>你可能会想，首先，这是避免 retain cycle 警告的一个技巧。</p>
<p>这不是重点，这个 self 的强引用是在block 执行时 被创建的，但是否使用 self 在 block 定义时就已经定下来了， 因此self (在block执行时) 会被 retain.</p>
<p>Apple 文档 中表示 “为了 non-trivial cycles ，你应该这样” ：</p>
<pre><code>MyViewController *myController = [[MyViewController alloc] init...];
// ...
MyViewController * __weak weakMyController = myController;
myController.completionHandler =  ^(NSInteger result) {
    MyViewController *strongMyController = weakMyController;
    if (strongMyController) {
        // ...
        [strongMyController dismissViewControllerAnimated:YES completion:nil];
        // ...
    }
    else {
        // Probably nothing...
    }
};
</code></pre><p>首先，我觉得这个例子看起来是错误的。如果 block 本身在 completionHandler 属性中被 retain 了，那么 self 如何被 delloc 和在 block 之外赋值为 nil 呢? completionHandler 属性可以被声明为 assign 或者 unsafe_unretained 的，来允许对象在 block 被传递之后被销毁。</p>
<p>我不能理解这样做的理由，如果其他对象需要这个对象（self），block 被传递的时候应该 retain 对象，所以 block 应该不被作为属性存储。这种情况下不应该用 <strong>weak/</strong>strong</p>
<p>总之，其他情况下，希望 weakSelf 变成 nil 的话，就像第二种情况解释那么写（在 block 之外定义一个弱应用并且在 block 里面使用）。</p>
<p>还有，Apple的 “trivial block” 是什么呢。我们的理解是 trivial block 是一个不被传送的 block ，它在一个良好定义和控制的作用域里面，weak 修饰只是为了避免循环引用。</p>
<p>虽然有 Kazuki Sakamoto 和 Tomohiko Furumoto) 讨论的 一 些 的 在线 参考, Matt Galloway 的 (Effective Objective-C 2.0 和 Pro Multithreading and Memory Management for iOS and OS X ，大多数开发者始终没有弄清楚概念。</p>
<p>在 block 内用强引用的优点是，抢占执行的时候的鲁棒性。在 block 执行的时候, 再次温故下上面的三个例子：</p>
<p>方案 1. 直接在 block 里面使用关键词 self</p>
<p>如果 block 被属性 retain，self 和 block 之间会有一个循环引用并且它们不会再被释放。如果 block 被传送并且被其他的对象 copy 了，self 在每一个 copy 里面被 retain</p>
<p>方案 2. 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用</p>
<p>不管 block 是否通过属性被 retain ，这里都不会发生循环引用。如果 block 被传递或者 copy 了，在执行的时候，weakSelf 可能已经变成 nil。</p>
<p>block 的执行可以抢占，而且对 weakSelf 指针的调用时序不同可以导致不同的结果(如：在一个特定的时序下 weakSelf 可能会变成nil)。</p>
<pre><code>__weak typeof(self) weakSelf = self;
dispatch_block_t block =  ^{
    [weakSelf doSomething]; // weakSelf != nil
    // preemption, weakSelf turned nil
    [weakSelf doSomethingElse]; // weakSelf == nil
};
</code></pre><p>方案 3. 在 block 外定义一个 <strong>weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 </strong>strong 的引用。</p>
<p>不管 block 是否通过属性被 retain ，这里也不会发生循环引用。如果 block 被传递到其他对象并且被复制了，执行的时候，weakSelf 可能被nil，因为强引用被赋值并且不会变成nil的时候，我们确保对象 在 block 调用的完整周期里面被 retain了，如果抢占发生了，随后的对 strongSelf 的执行会继续并且会产生一样的值。如果 strongSelf 的执行到 nil，那么在 block 不能正确执行前已经返回了。</p>
<pre><code>__weak typeof(self) weakSelf = self;
myObj.myBlock =  ^{
    __strong typeof(self) strongSelf = weakSelf;
    if (strongSelf) {
    [strongSelf doSomething]; // strongSelf != nil
    // preemption, strongSelf still not nil（抢占的时候，strongSelf 还是非 nil 的)
    [strongSelf doSomethingElse]; // strongSelf != nil
    }
    else {
        // Probably nothing...
        return;
    }
};
</code></pre><p>在ARC条件中，如果尝试用 -&gt; 符号访问一个实例变量，编译器会给出非常清晰的错误信息：</p>
<p>Dereferencing a <strong>weak pointer is not allowed due to possible null value caused by race condition, assign it to a strong variable first. (对一个 </strong>weak 指针的解引用不允许的，因为可能在竞态条件里面变成 null, 所以先把他定义成 strong 的属性)</p>
<p>可以用下面的代码展示</p>
<pre><code>__weak typeof(self) weakSelf = self;
myObj.myBlock =  ^{
    id localVal = weakSelf-&gt;someIVar;
};
</code></pre><p>在最后</p>
<pre><code>方案 1: 只能在 block 不是作为一个 property 的时候使用，否则会导致 retain cycle。

方案 2: 当 block 被声明为一个 property 的时候使用。

方案 3: 和并发执行有关。当涉及异步的服务的时候，block 可以在之后被执行，并且不会发生关于 self 是否存在的问题。
</code></pre><h3 id="五、IOS高效添加圆角效果"><a href="#五、IOS高效添加圆角效果" class="headerlink" title="五、IOS高效添加圆角效果"></a>五、IOS高效添加圆角效果</h3><p>误区一：</p>
<pre><code>view.layer.cornerRadius = 5
</code></pre><p>该代码经过测试是不会造成内存性能损耗。</p>
<pre><code>view.layer.masksToBounds = Yes // 遮罩layer层以下的视
图，使圆角生效
</code></pre><p>这代码才是造成性能损耗的关键因素。由于该代码会导致视图离屏渲染（Color Offscreen-Renderd Yellow）相关文章:<a href="http://www.jianshu.com/p/619cf14640f3" target="_blank" rel="external">UIKit性能调优实战讲解</a></p>
<p>注意事项：我们应该尽量避免重写 drawRect 方法，用CAShapeLayer代替图层绘制。不恰当的使用这个方法</p>
<p>会导致内存暴增。举个例子，iPhone6 上与屏幕等大的 UIView，即使重写一个空的 drawRect 方法，它也</p>
<p>至少占用 750 <em> 1134 </em> 4 字节 ≈ 3.4 Mb 的内存。在内存恶鬼drawRect 及其后续中，作者详细介绍了</p>
<p>其中原理，据他测试，在 iPhone6 上空的、与屏幕等大的视图重写 drawRect 方法会消耗 5.2 Mb 内存。</p>
<p>总之，能避免重写 drawRect 方法就尽可能避免。</p>
<p>其次，这种方法本质上是用遮罩层 mask 来实现，因此同样无可避免的会导致离屏渲染。我试着将此前 34 个</p>
<p>视图的圆角改用这种方法实现，结果 fps 掉到 11 左右。已经属于卡出翔的节奏了。</p>
<p>高效设置圆角实战：</p>
<h4 id="为-UIView-添加圆角"><a href="#为-UIView-添加圆角" class="headerlink" title="为 UIView 添加圆角"></a>为 UIView 添加圆角</h4><p>这种做法的原理是手动画出圆角。虽然我们之前说过，为普通的视图直接设置 cornerRadius 属性即可。但万一不可避免的需要使用 masksToBounds，就可以使用下面这种方法，它的核心代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func kt_drawRectWithRoundedCorner(radius radius: <span class="built_in">CGFloat</span>,       </span><br><span class="line">                       borderWidth: <span class="built_in">CGFloat</span>,</span><br><span class="line">                                  backgroundColor: <span class="built_in">UIColor</span>,</span><br><span class="line">                                  borderColor: <span class="built_in">UIColor</span>) -&gt; <span class="built_in">UIImage</span> &#123;    </span><br><span class="line">     <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(sizeToFit, <span class="literal">false</span>, <span class="built_in">UIScreen</span>.mainScreen().scale)</span><br><span class="line">     let context = <span class="built_in">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">     </span><br><span class="line">     <span class="built_in">CGContextMoveToPoint</span>(context, 开始位置);  <span class="comment">// 开始坐标右边开始</span></span><br><span class="line">     <span class="built_in">CGContextAddArcToPoint</span>(context, x1, y1, x2, y2, radius);  <span class="comment">// 这种类型的代码重复四次</span></span><br><span class="line">   </span><br><span class="line">     <span class="built_in">CGContextDrawPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(), .FillStroke)  </span><br><span class="line">     let output = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">     <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">     <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法返回的是 UIImage，也就是说我们利用 Core Graphics 自己画出了一个圆角矩形。除了一些必要的代码外，最核心的就是 CGContextAddArcToPoint 函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形。最后再从当前的绘图上下文中获取图片并返回。<br>有了这个图片后，我们创建一个 UIImageView 并插入到视图层级的底部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UIView</span> &#123;</span><br><span class="line">    func kt_addCorner(radius radius: <span class="built_in">CGFloat</span>,</span><br><span class="line">                      borderWidth: <span class="built_in">CGFloat</span>,</span><br><span class="line">                      backgroundColor: <span class="built_in">UIColor</span>,</span><br><span class="line">                      borderColor: <span class="built_in">UIColor</span>) &#123;</span><br><span class="line">        let imageView = <span class="built_in">UIImageView</span>(image: kt_drawRectWithRoundedCorner(radius: radius,</span><br><span class="line">                                    borderWidth: borderWidth,</span><br><span class="line">                                    backgroundColor: backgroundColor,</span><br><span class="line">                                    borderColor: borderColor))</span><br><span class="line">        <span class="keyword">self</span>.insertSubview(imageView, atIndex: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的代码可以在项目中找到，使用时，你只需要这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let view = <span class="built_in">UIView</span>(frame: <span class="built_in">CGRectMake</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">view.kt_addCorner(radius: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<h4 id="为-UIImageView-添加圆角"><a href="#为-UIImageView-添加圆角" class="headerlink" title="为 UIImageView 添加圆角"></a>为 UIImageView 添加圆角</h4><p>相比于上面一种实现方法，为 UIImageView 添加圆角更为常用。它的实现思路是直接截取图片：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    func kt_drawRectWithRoundedCorner(radius radius: <span class="built_in">CGFloat</span>, _ sizetoFit: <span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">        let rect = <span class="built_in">CGRect</span>(origin: <span class="built_in">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), size: sizetoFit)</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">false</span>, <span class="built_in">UIScreen</span>.mainScreen().scale)</span><br><span class="line">        <span class="built_in">CGContextAddPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(),</span><br><span class="line">            <span class="built_in">UIBezierPath</span>(roundedRect: rect, byRoundingCorners: <span class="built_in">UIRectCorner</span>.AllCorners,</span><br><span class="line">                cornerRadii: <span class="built_in">CGSize</span>(width: radius, height: radius)).CGPath)</span><br><span class="line">        <span class="built_in">CGContextClip</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>())</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">self</span>.drawInRect(rect)</span><br><span class="line">        <span class="built_in">CGContextDrawPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(), .FillStroke)</span><br><span class="line">        let output = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>圆角路径直接用贝塞尔曲线绘制，一个意外的 bonus 是还可以选择哪几个角有圆角效果。这个函数的效果是将原来的 UIImage 剪裁出圆角。配合着这函数，我们可以为 UIImageView 拓展一个设置圆角的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UIImageView</span> &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     / !!!只有当 imageView 不为nil 时，调用此方法才有效果</span><br><span class="line">     :param: radius 圆角半径</span><br><span class="line">     */</span></span><br><span class="line">    override func kt_addCorner(radius radius: <span class="built_in">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.image = <span class="keyword">self</span>.image?.kt_drawRectWithRoundedCorner(radius: radius, <span class="keyword">self</span>.bounds.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的代码可以在项目中找到，使用时，你只需要这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let imageView = let imgView1 = <span class="built_in">UIImageView</span>(image: <span class="built_in">UIImage</span>(name: <span class="string">""</span>))</span><br><span class="line">imageView.kt_addCorner(radius: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<h3 id="六、UIKit-性能优化-读后总结"><a href="#六、UIKit-性能优化-读后总结" class="headerlink" title="六、UIKit 性能优化 读后总结"></a>六、UIKit 性能优化 读后总结</h3><p>原文地址：<a href="http://www.jianshu.com/p/619cf14640f3" target="_blank" rel="external">UIKit性能调优实战讲解</a></p>
<h4 id="首选来说-为什么我们要进行UIKit优化？"><a href="#首选来说-为什么我们要进行UIKit优化？" class="headerlink" title="首选来说 为什么我们要进行UIKit优化？"></a>首选来说 为什么我们要进行UIKit优化？</h4><p>直接上图：</p>
<p> <img src="../images/笔记一/ios_frame_drop.png" alt="" title="Title"></p>
<p>如图所示，正常情况图层的渲染是通过CPU的计算和GPU的处理完成 正常的渲染流程的。</p>
<ul>
<li>当CPU和GPU的耗时时间控制在16.67ms之间（如第一部分）图层就会正常渲染。</li>
<li>当CPU和GPU的耗时时间超过了16.67ms（如第二部分）图层渲染就会掉帧，即屏幕就会出现花屏或者卡顿的现象。<br>所以，为了保证图层的正常渲染以及提高性能，我们着重从缓减CPU 和 GPU 不必要的消耗上，来做优化和调整。</li>
</ul>
<h4 id="1-为什么要把控件尽量设置成不透明，如果是透明的会有什么影响，如何检测这种影响？"><a href="#1-为什么要把控件尽量设置成不透明，如果是透明的会有什么影响，如何检测这种影响？" class="headerlink" title="1.为什么要把控件尽量设置成不透明，如果是透明的会有什么影响，如何检测这种影响？"></a>1.为什么要把控件尽量设置成不透明，如果是透明的会有什么影响，如何检测这种影响？</h4><ul>
<li>影响：如果控件带有透明度，这就会导致其控件与下层的控件的颜色 混合在一块。例如，上层是蓝色（透明度50%），下层是红色，那么最终显示的是紫色。<br>这种颜色的混合，需要GPU去处理混合的结果，这就一定程度的造成GPU额外的消耗。当实际层次更加复杂的时候（三层，五层）,GPU的消耗更加明显，对性能的影响就很明显了。如果将最上层的透明度设置为1，这样GPU就会忽略该层下面所有层次，节约了不必要的计算，从而提升性能。</li>
<li>检测：检测步骤，通过苹果自带的软件instruments中的core animation 选项 -&gt; 选择color Blended Layers 选项 红色区域就是透明度的设置.</li>
<li>优化措施：<ul>
<li>opaque = true 当然这个UIView默认就是 true的</li>
<li>alpha = 1 透明度尽量设置为1</li>
<li>最重要的是要设置背景颜色与父类一直,如果不设置默认会是透明的，另外clearColor（背景色透明）也不能设置，。label.backgroundColor = UIColor.WhiteColor()</li>
</ul>
</li>
</ul>
<h4 id="4-离屏渲染"><a href="#4-离屏渲染" class="headerlink" title="4.离屏渲染"></a>4.离屏渲染</h4><p>离屏渲染就是相对于正常的渲染流程（将图层直接合成到帧的缓冲区中），增加了一个额外的步骤（先创建屏幕外缓冲区，然后渲染到文理中，最后将结果渲染到帧的缓冲区），这个步骤中需要GPU额外的处理计算，造成很大消耗，所以俗称：离屏渲染。<br>我们先看看正常的渲染通道（Render-Pass）：<br> <img src="../images/笔记一/正常渲染.png" alt="" title="Title"><br>正常的渲染是OpenGL 提交一个命令到 command buff ，随后GPU 进行渲染 ，然后将渲染结果合成到（render buff）帧缓冲区中。<br>但是复杂的效果无法直接渲染出结果，需要分布渲染最后组合起来，比如添加一个蒙版（mask）：<br><img src="../images/笔记一/离屏渲染.png" alt="" title="Title"><br>如图所示，渲染流程中，分为好几部分进行的。在前两个渲染通道中，GPU分别得到纹理（texture，也就是相机图标）和layer(蓝色的蒙版)的渲染<br>结果。但这两个渲染结果没有直接放到render buff（帧缓冲区中），也就是发生了离屏渲染，知道第三个渲染通道，才把两者结合起来放入 render buff （帧缓冲区中）。离屏渲染实际上就是将渲染结果临时保存起来，等到用的时候再取出来，因此相对于普通渲染占用资源。<br>以下情况可能会导致离屏渲染:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.重写drawRect 方法。（一般情况下画图都用CAShapeLayer）</span><br><span class="line">2.有mask（圆角）或者阴影（layer.masksToBounds，layer.shadow），模糊效果也是一种mask (当使用圆角或者阴影是最好开启光栅化以达到缓冲的</span><br><span class="line">效果)</span><br><span class="line">3.光栅化 layer.shouldRasterize = true</span><br></pre></td></tr></table></figure>
<h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3. 光栅化"></a>3. 光栅化</h4><p>所谓光栅化其实就是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样的比较消耗资源的静态内容进行缓存、<br>可以得到一定幅度的性能提升。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label.layer.shouldRasterize = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>缓冲中的对象有效期只有100ms（0。1s）如果超过这个时间缓存会自动清理。光栅化是把双刃剑，先写入缓存再读取会消耗一定的时间，因此在没有必要的情况下尽量不要使用。除非碰到很复杂、静态的效果才能使用。会导致离屏渲染。</p>
<h3 id="4-图片大小"><a href="#4-图片大小" class="headerlink" title="4.图片大小"></a>4.图片大小</h3><p>尽量保持图片的大小合适，以及图片的格式 GPU所支持。如果图片偏大偏小，都需要GPU额外的去计算处理造成GPU的消耗，从而增加处理时间。<br>而图片的格式如果GPU 不支持的话同样需要GPU去做额外的转化，消耗大量的时间。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2015-07-08-Iterm2+ZSH-Shell" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/30/2015-07-08-Iterm2+ZSH-Shell/" class="article-date">
      <time datetime="2015-06-30T07:34:20.000Z" itemprop="datePublished">2015-06-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/30/2015-07-08-Iterm2+ZSH-Shell/">Iterm2+ZSH 打造终极Shell</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              Iterm2+ZSH 打造终极Shell
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工具类/">工具类</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2015/06/30/2015-07-08-Iterm2+ZSH-Shell/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2015-06-30-iOS-9-AppThinning" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/30/2015-06-30-iOS-9-AppThinning/" class="article-date">
      <time datetime="2015-06-30T07:34:20.000Z" itemprop="datePublished">2015-06-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/30/2015-06-30-iOS-9-AppThinning/">iOS 9 App Thinning</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              ios 9 新技术
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios-9-新技术/">ios 9 新技术</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2015/06/30/2015-06-30-iOS-9-AppThinning/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2015-07-20-ReactiveCocoa" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/30/2015-07-20-ReactiveCocoa/" class="article-date">
      <time datetime="2015-06-30T07:34:20.000Z" itemprop="datePublished">2015-06-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/30/2015-07-20-ReactiveCocoa/">ReactiveCocoa 学习之路(史上最全攻略)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              ReactiveCocoa 学习之路
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ReactiveCocoa/">ReactiveCocoa</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2015/06/30/2015-07-20-ReactiveCocoa/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2015-08-04-dependency-injection" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/30/2015-08-04-dependency-injection/" class="article-date">
      <time datetime="2015-06-30T07:34:20.000Z" itemprop="datePublished">2015-06-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/30/2015-08-04-dependency-injection/">关于IOS依赖注入(DI)那些事</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              dependency injection
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dependency-injection/">dependency injection</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2015/06/30/2015-08-04-dependency-injection/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2015-11-20-(BDD)calabash和cucumber" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/30/2015-11-20-(BDD)calabash和cucumber/" class="article-date">
      <time datetime="2015-06-30T07:34:20.000Z" itemprop="datePublished">2015-06-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/30/2015-11-20-(BDD)calabash和cucumber/">BDD开发 calabash 和 cucumber的使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              Calabash是一款开源的跨平台UI测试工具，目前支持iOS和Android。
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BDD/">BDD</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a href="/2015/06/30/2015-11-20-(BDD)calabash和cucumber/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 RunningYoung
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/RunningYoung/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo">Yelee</a> by runningyoung
            </div>
        </div>

        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >Site Visitors: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">Page Hits: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(https://runningyoung.github.io/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-64735170-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>