<!DOCTYPE html>
<html >
<head>
  <meta charset="utf-8">
  
  <title>【iOS读书笔记系列（一）】 | New World</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="读书笔记（一）">
<meta property="og:type" content="article">
<meta property="og:title" content="【iOS读书笔记系列（一）】">
<meta property="og:url" content="https://runningyoung.github.io/2016/02/24/2016-03-12-read1/index.html">
<meta property="og:site_name" content="New World">
<meta property="og:description" content="读书笔记（一）">
<meta property="og:image" content="https://runningyoung.github.io/../images/笔记一/ios_frame_drop.png">
<meta property="og:image" content="https://runningyoung.github.io/../images/笔记一/正常渲染.png">
<meta property="og:image" content="https://runningyoung.github.io/../images/笔记一/离屏渲染.png">
<meta property="og:updated_time" content="2016-04-12T02:53:53.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【iOS读书笔记系列（一）】">
<meta name="twitter:description" content="读书笔记（一）">
<meta name="twitter:image" content="https://runningyoung.github.io/../images/笔记一/ios_frame_drop.png">
  
    <link rel="alternative" href="/atom.xml" title="New World" type="application/atom+xml">
  
  
    <link rel="icon" href="https://runningyoung.github.io/img/avatar.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="https://runningyoung.github.io/apple-touch-icon.png">
  
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = https://runningyoung.github.io;
      </script>
  

  

  
      <script>
          var _hmt = _hmt || [];
          (function() {
              var hm = document.createElement("script");
              hm.src = "//hm.baidu.com/hm.js?200c79969158a0fa1fe0632060fe4221";
              var s = document.getElementsByTagName("script")[0]; 
              s.parentNode.insertBefore(hm, s);
          })();
      </script>
  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="https://runningyoung.github.io/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">RunningYoung</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="https://runningyoung.github.io/">主页</a></li>
                        
                            <li><a href="https://runningyoung.github.io/archives/">所有文章</a></li>
                        
                            <li><a href="https://runningyoung.github.io/tags/">标签云</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/RunningYoung" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/BDD/" style="font-size: 10px;">BDD</a> <a href="/tags/Block/" style="font-size: 10px;">Block</a> <a href="/tags/ReactiveCocoa/" style="font-size: 10px;">ReactiveCocoa</a> <a href="/tags/dependency-injection/" style="font-size: 10px;">dependency injection</a> <a href="/tags/ios-9-新技术/" style="font-size: 10px;">ios 9 新技术</a> <a href="/tags/jenkins/" style="font-size: 20px;">jenkins</a> <a href="/tags/工具类/" style="font-size: 10px;">工具类</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">专注于iOS开发</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">RunningYoung</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="https://runningyoung.github.io/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">RunningYoung</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/RunningYoung" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-2016-03-12-read1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/24/2016-03-12-read1/" class="article-date">
      <time datetime="2016-02-24T06:28:01.000Z" itemprop="datePublished">2016-02-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      【iOS读书笔记系列（一）】
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="读书笔记（一）"><a href="#读书笔记（一）" class="headerlink" title="读书笔记（一）"></a>读书笔记（一）</h3><a id="more"></a>
<h4 id="一、instancetype-和-id-作为初始化实例-返回值的不同"><a href="#一、instancetype-和-id-作为初始化实例-返回值的不同" class="headerlink" title="一、instancetype 和 id 作为初始化实例 返回值的不同"></a>一、instancetype 和 id 作为初始化实例 返回值的不同</h4><p>Objective-C的一些使用惯例不仅仅是好的编程习惯，更是给编译器的隐藏指令。<br>例如， alloc 和 init 的返回类型都是 id ，然而在Xcode中，编译器会检查所有正确类型。它是怎么做到的呢？<br>在Cocoa中，约定 alloc 或 init 的方法总是返回接收器类实例的对象。据说这些方法有一个相关返回类型。<br>虽然类构造方法也是返回 id ，但是类构造方法并没有做同样的类型检查，因为它们不遵循命名规范。<br>你可以自己试着这样：</p>
<pre><code>[[[NSArray alloc] init] mediaPlaybackAllowsAirPlay]; // ❗ &quot;No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`&quot;

[[NSArray array] mediaPlaybackAllowsAirPlay]; // (No error)
</code></pre><p>由于alloc 和 init 作为相关返回类型遵循命名规范，执行对NSArray的正确类型检查。然而，等价类构造函数array不遵循命名规范，它被认为是id类型。<br>id类型对禁用类型安全性检查非常有用，但当你确实需要它的时候却没有时，情况会变得非常糟糕。<br>另一种显示声明返回类型（在之前例子中的 (NSArray *)）的方式有了稍微的改进，但是它不利于子类的发挥。<br>所以编译器从这里介入以解决Objective-C类型系统的这个永恒边界情况：<br>instancetype 关键字，它可以表示一个方法的相关返回类型。例如：</p>
<pre><code>@interface Person
+(instancetype)personWithName:(NSString *)name;
@end
</code></pre><ul>
<li>instancetype 与 id 不一样, instancetype 只能在方法声明中作为返回类型使用。</li>
</ul>
<p>使用 instancetype ，编译器将正确的推断出 +personWithName: 是 Person 的一个实例。<br>为了在不久的将来使用 instancetype ，你可以在Foundation中查找类构造函数。例如UICollectionViewLayoutAttributes 就已经正在使用 instancetype 了。</p>
<h3 id="二、iOS为什么不要在init初始化方法里调用self-view"><a href="#二、iOS为什么不要在init初始化方法里调用self-view" class="headerlink" title="二、iOS为什么不要在init初始化方法里调用self.view"></a>二、iOS为什么不要在init初始化方法里调用self.view</h3><p>首先.如果你调用self.view的时候,就会调用view的getter方法, 这个时候,view是空的,那么系统就会自动给你创建一个view,然后就会触发ViewDidLoad方法.那么这个时候,如果你init方法里有数组初始化.但是你还没走到那步,而直接就给数组赋值了,那么这个值赋值给了一个不存在的数组.这样就容易出现错误.所以,尽量不要在init方法里写可视化控件的语句.</p>
<h3 id="三、忽略编译警告"><a href="#三、忽略编译警告" class="headerlink" title="三、忽略编译警告"></a>三、忽略编译警告</h3><p>如果你知道你的代码不会导致内存泄露，你可以通过加入这些代码忽略这些警告</p>
<pre><code>#pragma clang diagnostic push
#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;

[myObj performSelector:mySelector withObject:name];

#pragma clang diagnostic pop
</code></pre><p>注意我们是如何在相关代码上下文中用 pragma 停用 -Warc-performSelector-leaks 检查的。这确保我们没有全局禁用。如果全局禁用，可能会导致错误。</p>
<p>使用 #pragma unused():忽略没用使用变量的编译警告</p>
<pre><code>-(NSInteger)giveMeFive
{
    NSString *foo;
    #pragma unused (foo)

    return 5;
}
</code></pre><h3 id="四、Block的深入学习"><a href="#四、Block的深入学习" class="headerlink" title="四、Block的深入学习"></a>四、Block的深入学习</h3><h4 id="一些关键点："><a href="#一些关键点：" class="headerlink" title="一些关键点："></a>一些关键点：</h4><pre><code>block 是在栈上创建的
block 可以复制到堆上
Block会捕获栈上的变量(或指针)，将其复制为自己私有的const(变量)。
(如果在Block中修改Block块外的)栈上的变量和指针，那么这些变量和指针必须用__block关键字申明(译者注：否则就会跟上面的情况一样只是捕获他们的瞬时值)。
block 可以声明成全局静态的
</code></pre><p>如果 block 没有在其他地方被保持，那么它会随着栈生存并且当栈帧（stack frame）返回的时候消失。仅存在于栈上时，block对对象访问的内存管理和生命周期没有任何影响。</p>
<p>如果 block 需要在栈帧返回的时候存在，它们需要明确地被复制到堆上，这样，block 会像其他 Cocoa 对象一样增加引用计数。当它们被复制的时候，它会带着它们的捕获作用域一起，retain 他们所有引用的对象。</p>
<p>如果一个 block引用了一个栈变量或指针，那么这个block初始化的时候会拥有这个变量或指针的const副本，所以(被捕获之后再在栈中改变这个变量或指针的值)是不起作用的。(译者注：所以这时候我们在block中对这种变量进行赋值会编译报错:Variable is not assignable(missing __block type specifier)，因为他们是副本而且是const的.具体见下面的例程)。</p>
<p>当一个 block 被复制后，__block 声明的栈变量的引用被复制到了堆里，复制完成之后，无论是栈上的block还是刚刚产生在堆上的block(栈上block的副本)都会引用该变量在堆上的副本。</p>
<p>(下面代码是译者加的)</p>
<pre><code>...
CGFloat blockInt = 10;
void (^playblock)(void) = ^{
    NSLog(@&quot;blockInt = %zd&quot;, blockInt);
};
blockInt ++;
playblock();
...

//结果为:blockInt = 10
</code></pre><p>最重要的事情是 __block 声明的变量和指针在 block 里面是作为显示操作真实值/对象的结构来对待的。</p>
<p>block 在 Objective-C 的 runtime(运行时) 里面被当作一等公民对待：他们有一个 isa 指针，一个类也是用 isa 指针在Objective-C 运行时来访问方法和存储数据的。在非 ARC 环境肯定会把它搞得很糟糕，并且悬挂指针会导致 crash。__block 仅仅对 block 内的变量起作用，它只是简单地告诉 block：</p>
<pre><code>嗨，这个指针或者原始的类型依赖它们在的栈。请用一个栈上的新变量来引用它。我是说，请对它进行双重解引用，不要 retain 它。 谢谢，哥们。
</code></pre><p>如果在定义之后但是 block 没有被调用前，对象被释放了，那么 block 的执行会导致 crash。 __block 变量不会在 block 中被持有，最后… 指针、引用、解引用以及引用计数变得一团糟。</p>
<h4 id="self-的循环引用"><a href="#self-的循环引用" class="headerlink" title="self 的循环引用"></a>self 的循环引用</h4><p>当使用代码块和异步分发的时候，要注意避免引用循环。 总是使用 weak 来引用对象，避免引用循环。（译者注：这里更为优雅的方式是采用影子变量@weakify/@strongify 这里有更为详细的说明） 此外，把持有 block 的属性设置为 nil (比如 self.completionBlock = nil) 是一个好的实践。它会打破 block 捕获的作用域带来的引用循环。</p>
<p>例子:</p>
<pre><code>__weak __typeof(self) weakSelf = self;
[self executeBlock:^(NSData *data, NSError *error) {
    [weakSelf doSomethingWithData:data];
}];
</code></pre><p>不要这样:</p>
<pre><code>[self executeBlock:^(NSData *data, NSError *error) {
    [self doSomethingWithData:data];
}];
</code></pre><p>多个语句的例子:</p>
<pre><code>__weak __typeof(self)weakSelf = self;
[self executeBlock:^(NSData *data, NSError *error) {
    __strong __typeof(weakSelf) strongSelf = weakSelf;
    if (strongSelf) {
        [strongSelf doSomethingWithData:data];
        [strongSelf doSomethingWithData:data];
    }
}];
</code></pre><p>不要这样:</p>
<pre><code>__weak __typeof(self)weakSelf = self;
[self executeBlock:^(NSData *data, NSError *error) {
    [weakSelf doSomethingWithData:data];
    [weakSelf doSomethingWithData:data];
}];
</code></pre><p>你应该把这两行代码作为 snippet 加到 Xcode 里面并且总是这样使用它们。</p>
<pre><code>__weak __typeof(self)weakSelf = self;
__strong __typeof(weakSelf)strongSelf = weakSelf;
</code></pre><p>这里我们来讨论下 block 里面的 self 的 <strong>weak 和 </strong>strong 限定词的一些微妙的地方。简而言之，我们可以参考 self 在 block 里面的三种不同情况。</p>
<pre><code>直接在 block 里面使用关键词 self
在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用
在 block 外定义一个 __weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 __strong 的引用。
</code></pre><p>方案 1. 直接在 block 里面使用关键词 self</p>
<p>如果我们直接在 block 里面用 self 关键字，对象会在 block 的定义时候被 retain，（实际上 block 是 copied 但是为了简单我们可以忽略这个）。一个 const 的对 self 的引用在 block 里面有自己的位置并且它会影响对象的引用计数。如果这个block被其他的类使用并且(或者)彼此间传来传去，我们可能想要在 block 中保留 self，就像其他在 block 中使用的对象一样. 因为他们是block执行所需要的.</p>
<pre><code>dispatch_block_t completionBlock = ^{
    NSLog(@&quot;%@&quot;, self);
}

MyViewController *myController = [[MyViewController alloc] init...];
[self presentViewController:myController
                animated:YES
                completion:completionHandler];
</code></pre><p>没啥大不了。但是如果通过一个属性中的 self 保留 了这个 block（就像下面的例程一样）,对象( self )保留了 block 会怎么样呢？</p>
<pre><code>self.completionHandler = ^{
    NSLog(@&quot;%@&quot;, self);
}

MyViewController *myController = [[MyViewController alloc] init...];
[self presentViewController:myController
                animated:YES
                completion:self.completionHandler];
</code></pre><p>这就是有名的 retain cycle, 并且我们通常应该避免它。这种情况下我们收到 CLANG 的警告：</p>
<pre><code>Capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle （在 block 里面发现了 `self` 的强引用，可能会导致循环引用）
</code></pre><p>所以 __weak 就有用武之地了。</p>
<p>方案 2. 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用</p>
<p>这样会避免循坏引用，也是通常情况下我们的block作为类的属性被self retain 的时候会做的。</p>
<pre><code>__weak typeof(self) weakSelf = self;
self.completionHandler = ^{
    NSLog(@&quot;%@&quot;, weakSelf);
};

MyViewController *myController = [[MyViewController alloc] init...];
[self presentViewController:myController
                animated:YES
                completion:self.completionHandler];
</code></pre><p>这个情况下 block 没有 retain 对象并且对象在属性里面 retain 了 block 。所以这样我们能保证了安全的访问 self。 不过糟糕的是，它可能被设置成 nil 的。问题是：如何让 self 在 block 里面安全地被销毁。</p>
<p>考虑这么个情况：block 作为属性(property)赋值的结果，从一个对象被复制到另一个对象(如 myController)，在这个复制的 block 执行之前，前者（即之前的那个对象）已经被解除分配。</p>
<p>下面的更有意思。</p>
<p>方案 3. 在 block 外定义一个 <strong>weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 </strong>strong 的引用</p>
<p>你可能会想，首先，这是避免 retain cycle 警告的一个技巧。</p>
<p>这不是重点，这个 self 的强引用是在block 执行时 被创建的，但是否使用 self 在 block 定义时就已经定下来了， 因此self (在block执行时) 会被 retain.</p>
<p>Apple 文档 中表示 “为了 non-trivial cycles ，你应该这样” ：</p>
<pre><code>MyViewController *myController = [[MyViewController alloc] init...];
// ...
MyViewController * __weak weakMyController = myController;
myController.completionHandler =  ^(NSInteger result) {
    MyViewController *strongMyController = weakMyController;
    if (strongMyController) {
        // ...
        [strongMyController dismissViewControllerAnimated:YES completion:nil];
        // ...
    }
    else {
        // Probably nothing...
    }
};
</code></pre><p>首先，我觉得这个例子看起来是错误的。如果 block 本身在 completionHandler 属性中被 retain 了，那么 self 如何被 delloc 和在 block 之外赋值为 nil 呢? completionHandler 属性可以被声明为 assign 或者 unsafe_unretained 的，来允许对象在 block 被传递之后被销毁。</p>
<p>我不能理解这样做的理由，如果其他对象需要这个对象（self），block 被传递的时候应该 retain 对象，所以 block 应该不被作为属性存储。这种情况下不应该用 <strong>weak/</strong>strong</p>
<p>总之，其他情况下，希望 weakSelf 变成 nil 的话，就像第二种情况解释那么写（在 block 之外定义一个弱应用并且在 block 里面使用）。</p>
<p>还有，Apple的 “trivial block” 是什么呢。我们的理解是 trivial block 是一个不被传送的 block ，它在一个良好定义和控制的作用域里面，weak 修饰只是为了避免循环引用。</p>
<p>虽然有 Kazuki Sakamoto 和 Tomohiko Furumoto) 讨论的 一 些 的 在线 参考, Matt Galloway 的 (Effective Objective-C 2.0 和 Pro Multithreading and Memory Management for iOS and OS X ，大多数开发者始终没有弄清楚概念。</p>
<p>在 block 内用强引用的优点是，抢占执行的时候的鲁棒性。在 block 执行的时候, 再次温故下上面的三个例子：</p>
<p>方案 1. 直接在 block 里面使用关键词 self</p>
<p>如果 block 被属性 retain，self 和 block 之间会有一个循环引用并且它们不会再被释放。如果 block 被传送并且被其他的对象 copy 了，self 在每一个 copy 里面被 retain</p>
<p>方案 2. 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用</p>
<p>不管 block 是否通过属性被 retain ，这里都不会发生循环引用。如果 block 被传递或者 copy 了，在执行的时候，weakSelf 可能已经变成 nil。</p>
<p>block 的执行可以抢占，而且对 weakSelf 指针的调用时序不同可以导致不同的结果(如：在一个特定的时序下 weakSelf 可能会变成nil)。</p>
<pre><code>__weak typeof(self) weakSelf = self;
dispatch_block_t block =  ^{
    [weakSelf doSomething]; // weakSelf != nil
    // preemption, weakSelf turned nil
    [weakSelf doSomethingElse]; // weakSelf == nil
};
</code></pre><p>方案 3. 在 block 外定义一个 <strong>weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 </strong>strong 的引用。</p>
<p>不管 block 是否通过属性被 retain ，这里也不会发生循环引用。如果 block 被传递到其他对象并且被复制了，执行的时候，weakSelf 可能被nil，因为强引用被赋值并且不会变成nil的时候，我们确保对象 在 block 调用的完整周期里面被 retain了，如果抢占发生了，随后的对 strongSelf 的执行会继续并且会产生一样的值。如果 strongSelf 的执行到 nil，那么在 block 不能正确执行前已经返回了。</p>
<pre><code>__weak typeof(self) weakSelf = self;
myObj.myBlock =  ^{
    __strong typeof(self) strongSelf = weakSelf;
    if (strongSelf) {
    [strongSelf doSomething]; // strongSelf != nil
    // preemption, strongSelf still not nil（抢占的时候，strongSelf 还是非 nil 的)
    [strongSelf doSomethingElse]; // strongSelf != nil
    }
    else {
        // Probably nothing...
        return;
    }
};
</code></pre><p>在ARC条件中，如果尝试用 -&gt; 符号访问一个实例变量，编译器会给出非常清晰的错误信息：</p>
<p>Dereferencing a <strong>weak pointer is not allowed due to possible null value caused by race condition, assign it to a strong variable first. (对一个 </strong>weak 指针的解引用不允许的，因为可能在竞态条件里面变成 null, 所以先把他定义成 strong 的属性)</p>
<p>可以用下面的代码展示</p>
<pre><code>__weak typeof(self) weakSelf = self;
myObj.myBlock =  ^{
    id localVal = weakSelf-&gt;someIVar;
};
</code></pre><p>在最后</p>
<pre><code>方案 1: 只能在 block 不是作为一个 property 的时候使用，否则会导致 retain cycle。

方案 2: 当 block 被声明为一个 property 的时候使用。

方案 3: 和并发执行有关。当涉及异步的服务的时候，block 可以在之后被执行，并且不会发生关于 self 是否存在的问题。
</code></pre><h3 id="五、IOS高效添加圆角效果"><a href="#五、IOS高效添加圆角效果" class="headerlink" title="五、IOS高效添加圆角效果"></a>五、IOS高效添加圆角效果</h3><p>误区一：</p>
<pre><code>view.layer.cornerRadius = 5
</code></pre><p>该代码经过测试是不会造成内存性能损耗。</p>
<pre><code>view.layer.masksToBounds = Yes // 遮罩layer层以下的视
图，使圆角生效
</code></pre><p>这代码才是造成性能损耗的关键因素。由于该代码会导致视图离屏渲染（Color Offscreen-Renderd Yellow）相关文章:<a href="http://www.jianshu.com/p/619cf14640f3" target="_blank" rel="external">UIKit性能调优实战讲解</a></p>
<p>注意事项：我们应该尽量避免重写 drawRect 方法，用CAShapeLayer代替图层绘制。不恰当的使用这个方法</p>
<p>会导致内存暴增。举个例子，iPhone6 上与屏幕等大的 UIView，即使重写一个空的 drawRect 方法，它也</p>
<p>至少占用 750 <em> 1134 </em> 4 字节 ≈ 3.4 Mb 的内存。在内存恶鬼drawRect 及其后续中，作者详细介绍了</p>
<p>其中原理，据他测试，在 iPhone6 上空的、与屏幕等大的视图重写 drawRect 方法会消耗 5.2 Mb 内存。</p>
<p>总之，能避免重写 drawRect 方法就尽可能避免。</p>
<p>其次，这种方法本质上是用遮罩层 mask 来实现，因此同样无可避免的会导致离屏渲染。我试着将此前 34 个</p>
<p>视图的圆角改用这种方法实现，结果 fps 掉到 11 左右。已经属于卡出翔的节奏了。</p>
<p>高效设置圆角实战：</p>
<h4 id="为-UIView-添加圆角"><a href="#为-UIView-添加圆角" class="headerlink" title="为 UIView 添加圆角"></a>为 UIView 添加圆角</h4><p>这种做法的原理是手动画出圆角。虽然我们之前说过，为普通的视图直接设置 cornerRadius 属性即可。但万一不可避免的需要使用 masksToBounds，就可以使用下面这种方法，它的核心代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func kt_drawRectWithRoundedCorner(radius radius: <span class="built_in">CGFloat</span>,       </span><br><span class="line">                       borderWidth: <span class="built_in">CGFloat</span>,</span><br><span class="line">                                  backgroundColor: <span class="built_in">UIColor</span>,</span><br><span class="line">                                  borderColor: <span class="built_in">UIColor</span>) -&gt; <span class="built_in">UIImage</span> &#123;    </span><br><span class="line">     <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(sizeToFit, <span class="literal">false</span>, <span class="built_in">UIScreen</span>.mainScreen().scale)</span><br><span class="line">     let context = <span class="built_in">UIGraphicsGetCurrentContext</span>()</span><br><span class="line">     </span><br><span class="line">     <span class="built_in">CGContextMoveToPoint</span>(context, 开始位置);  <span class="comment">// 开始坐标右边开始</span></span><br><span class="line">     <span class="built_in">CGContextAddArcToPoint</span>(context, x1, y1, x2, y2, radius);  <span class="comment">// 这种类型的代码重复四次</span></span><br><span class="line">   </span><br><span class="line">     <span class="built_in">CGContextDrawPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(), .FillStroke)  </span><br><span class="line">     let output = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">     <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">     <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法返回的是 UIImage，也就是说我们利用 Core Graphics 自己画出了一个圆角矩形。除了一些必要的代码外，最核心的就是 CGContextAddArcToPoint 函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形。最后再从当前的绘图上下文中获取图片并返回。<br>有了这个图片后，我们创建一个 UIImageView 并插入到视图层级的底部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UIView</span> &#123;</span><br><span class="line">    func kt_addCorner(radius radius: <span class="built_in">CGFloat</span>,</span><br><span class="line">                      borderWidth: <span class="built_in">CGFloat</span>,</span><br><span class="line">                      backgroundColor: <span class="built_in">UIColor</span>,</span><br><span class="line">                      borderColor: <span class="built_in">UIColor</span>) &#123;</span><br><span class="line">        let imageView = <span class="built_in">UIImageView</span>(image: kt_drawRectWithRoundedCorner(radius: radius,</span><br><span class="line">                                    borderWidth: borderWidth,</span><br><span class="line">                                    backgroundColor: backgroundColor,</span><br><span class="line">                                    borderColor: borderColor))</span><br><span class="line">        <span class="keyword">self</span>.insertSubview(imageView, atIndex: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的代码可以在项目中找到，使用时，你只需要这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let view = <span class="built_in">UIView</span>(frame: <span class="built_in">CGRectMake</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">view.kt_addCorner(radius: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<h4 id="为-UIImageView-添加圆角"><a href="#为-UIImageView-添加圆角" class="headerlink" title="为 UIImageView 添加圆角"></a>为 UIImageView 添加圆角</h4><p>相比于上面一种实现方法，为 UIImageView 添加圆角更为常用。它的实现思路是直接截取图片：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    func kt_drawRectWithRoundedCorner(radius radius: <span class="built_in">CGFloat</span>, _ sizetoFit: <span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">        let rect = <span class="built_in">CGRect</span>(origin: <span class="built_in">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), size: sizetoFit)</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">false</span>, <span class="built_in">UIScreen</span>.mainScreen().scale)</span><br><span class="line">        <span class="built_in">CGContextAddPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(),</span><br><span class="line">            <span class="built_in">UIBezierPath</span>(roundedRect: rect, byRoundingCorners: <span class="built_in">UIRectCorner</span>.AllCorners,</span><br><span class="line">                cornerRadii: <span class="built_in">CGSize</span>(width: radius, height: radius)).CGPath)</span><br><span class="line">        <span class="built_in">CGContextClip</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>())</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">self</span>.drawInRect(rect)</span><br><span class="line">        <span class="built_in">CGContextDrawPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(), .FillStroke)</span><br><span class="line">        let output = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>圆角路径直接用贝塞尔曲线绘制，一个意外的 bonus 是还可以选择哪几个角有圆角效果。这个函数的效果是将原来的 UIImage 剪裁出圆角。配合着这函数，我们可以为 UIImageView 拓展一个设置圆角的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="built_in">UIImageView</span> &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     / !!!只有当 imageView 不为nil 时，调用此方法才有效果</span><br><span class="line">     :param: radius 圆角半径</span><br><span class="line">     */</span></span><br><span class="line">    override func kt_addCorner(radius radius: <span class="built_in">CGFloat</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.image = <span class="keyword">self</span>.image?.kt_drawRectWithRoundedCorner(radius: radius, <span class="keyword">self</span>.bounds.size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的代码可以在项目中找到，使用时，你只需要这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let imageView = let imgView1 = <span class="built_in">UIImageView</span>(image: <span class="built_in">UIImage</span>(name: <span class="string">""</span>))</span><br><span class="line">imageView.kt_addCorner(radius: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<h3 id="六、UIKit-性能优化-读后总结"><a href="#六、UIKit-性能优化-读后总结" class="headerlink" title="六、UIKit 性能优化 读后总结"></a>六、UIKit 性能优化 读后总结</h3><p>原文地址：<a href="http://www.jianshu.com/p/619cf14640f3" target="_blank" rel="external">UIKit性能调优实战讲解</a></p>
<h4 id="首选来说-为什么我们要进行UIKit优化？"><a href="#首选来说-为什么我们要进行UIKit优化？" class="headerlink" title="首选来说 为什么我们要进行UIKit优化？"></a>首选来说 为什么我们要进行UIKit优化？</h4><p>直接上图：</p>
<p> <img src="../images/笔记一/ios_frame_drop.png" alt="" title="Title"></p>
<p>如图所示，正常情况图层的渲染是通过CPU的计算和GPU的处理完成 正常的渲染流程的。</p>
<ul>
<li>当CPU和GPU的耗时时间控制在16.67ms之间（如第一部分）图层就会正常渲染。</li>
<li>当CPU和GPU的耗时时间超过了16.67ms（如第二部分）图层渲染就会掉帧，即屏幕就会出现花屏或者卡顿的现象。<br>所以，为了保证图层的正常渲染以及提高性能，我们着重从缓减CPU 和 GPU 不必要的消耗上，来做优化和调整。</li>
</ul>
<h4 id="1-为什么要把控件尽量设置成不透明，如果是透明的会有什么影响，如何检测这种影响？"><a href="#1-为什么要把控件尽量设置成不透明，如果是透明的会有什么影响，如何检测这种影响？" class="headerlink" title="1.为什么要把控件尽量设置成不透明，如果是透明的会有什么影响，如何检测这种影响？"></a>1.为什么要把控件尽量设置成不透明，如果是透明的会有什么影响，如何检测这种影响？</h4><ul>
<li>影响：如果控件带有透明度，这就会导致其控件与下层的控件的颜色 混合在一块。例如，上层是蓝色（透明度50%），下层是红色，那么最终显示的是紫色。<br>这种颜色的混合，需要GPU去处理混合的结果，这就一定程度的造成GPU额外的消耗。当实际层次更加复杂的时候（三层，五层）,GPU的消耗更加明显，对性能的影响就很明显了。如果将最上层的透明度设置为1，这样GPU就会忽略该层下面所有层次，节约了不必要的计算，从而提升性能。</li>
<li>检测：检测步骤，通过苹果自带的软件instruments中的core animation 选项 -&gt; 选择color Blended Layers 选项 红色区域就是透明度的设置.</li>
<li>优化措施：<ul>
<li>opaque = true 当然这个UIView默认就是 true的</li>
<li>alpha = 1 透明度尽量设置为1</li>
<li>最重要的是要设置背景颜色与父类一直,如果不设置默认会是透明的，另外clearColor（背景色透明）也不能设置，。label.backgroundColor = UIColor.WhiteColor()</li>
</ul>
</li>
</ul>
<h4 id="4-离屏渲染"><a href="#4-离屏渲染" class="headerlink" title="4.离屏渲染"></a>4.离屏渲染</h4><p>离屏渲染就是相对于正常的渲染流程（将图层直接合成到帧的缓冲区中），增加了一个额外的步骤（先创建屏幕外缓冲区，然后渲染到文理中，最后将结果渲染到帧的缓冲区），这个步骤中需要GPU额外的处理计算，造成很大消耗，所以俗称：离屏渲染。<br>我们先看看正常的渲染通道（Render-Pass）：<br> <img src="../images/笔记一/正常渲染.png" alt="" title="Title"><br>正常的渲染是OpenGL 提交一个命令到 command buff ，随后GPU 进行渲染 ，然后将渲染结果合成到（render buff）帧缓冲区中。<br>但是复杂的效果无法直接渲染出结果，需要分布渲染最后组合起来，比如添加一个蒙版（mask）：<br><img src="../images/笔记一/离屏渲染.png" alt="" title="Title"><br>如图所示，渲染流程中，分为好几部分进行的。在前两个渲染通道中，GPU分别得到纹理（texture，也就是相机图标）和layer(蓝色的蒙版)的渲染<br>结果。但这两个渲染结果没有直接放到render buff（帧缓冲区中），也就是发生了离屏渲染，知道第三个渲染通道，才把两者结合起来放入 render buff （帧缓冲区中）。离屏渲染实际上就是将渲染结果临时保存起来，等到用的时候再取出来，因此相对于普通渲染占用资源。<br>以下情况可能会导致离屏渲染:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.重写drawRect 方法。（一般情况下画图都用CAShapeLayer）</span><br><span class="line">2.有mask（圆角）或者阴影（layer.masksToBounds，layer.shadow），模糊效果也是一种mask (当使用圆角或者阴影是最好开启光栅化以达到缓冲的</span><br><span class="line">效果)</span><br><span class="line">3.光栅化 layer.shouldRasterize = true</span><br></pre></td></tr></table></figure>
<h4 id="3-光栅化"><a href="#3-光栅化" class="headerlink" title="3. 光栅化"></a>3. 光栅化</h4><p>所谓光栅化其实就是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样的比较消耗资源的静态内容进行缓存、<br>可以得到一定幅度的性能提升。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label.layer.shouldRasterize = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>缓冲中的对象有效期只有100ms（0。1s）如果超过这个时间缓存会自动清理。光栅化是把双刃剑，先写入缓存再读取会消耗一定的时间，因此在没有必要的情况下尽量不要使用。除非碰到很复杂、静态的效果才能使用。会导致离屏渲染。</p>
<h3 id="4-图片大小"><a href="#4-图片大小" class="headerlink" title="4.图片大小"></a>4.图片大小</h3><p>尽量保持图片的大小合适，以及图片的格式 GPU所支持。如果图片偏大偏小，都需要GPU额外的去计算处理造成GPU的消耗，从而增加处理时间。<br>而图片的格式如果GPU 不支持的话同样需要GPU去做额外的转化，消耗大量的时间。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/02/24/2016-03-12-read1/">【iOS读书笔记系列（一）】</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">RunningYoung</a></p>
        <p><span>发布时间:</span>2016-02-24, 14:28:01</p>
        <p><span>最后更新:</span>2016-04-12, 10:53:53</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/02/24/2016-03-12-read1/" title="【iOS读书笔记系列（一）】">https://runningyoung.github.io/2016/02/24/2016-03-12-read1/</a>
            <span class="copy-path" data-clipboard-text="原文: https://runningyoung.github.io/2016/02/24/2016-03-12-read1/　　作者: RunningYoung" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/03/07/2016-03-14-Block/">
                    Block源码解析和深入理解
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2015/06/30/2015-07-08-Iterm2+ZSH-Shell/">
                    Iterm2+ZSH 打造终极Shell
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#读书笔记（一）"><span class="toc-number">1.</span> <span class="toc-text">读书笔记（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、instancetype-和-id-作为初始化实例-返回值的不同"><span class="toc-number">1.1.</span> <span class="toc-text">一、instancetype 和 id 作为初始化实例 返回值的不同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、iOS为什么不要在init初始化方法里调用self-view"><span class="toc-number">2.</span> <span class="toc-text">二、iOS为什么不要在init初始化方法里调用self.view</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、忽略编译警告"><span class="toc-number">3.</span> <span class="toc-text">三、忽略编译警告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、Block的深入学习"><span class="toc-number">4.</span> <span class="toc-text">四、Block的深入学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一些关键点："><span class="toc-number">4.1.</span> <span class="toc-text">一些关键点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#self-的循环引用"><span class="toc-number">4.2.</span> <span class="toc-text">self 的循环引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、IOS高效添加圆角效果"><span class="toc-number">5.</span> <span class="toc-text">五、IOS高效添加圆角效果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为-UIView-添加圆角"><span class="toc-number">5.1.</span> <span class="toc-text">为 UIView 添加圆角</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为-UIImageView-添加圆角"><span class="toc-number">5.2.</span> <span class="toc-text">为 UIImageView 添加圆角</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、UIKit-性能优化-读后总结"><span class="toc-number">6.</span> <span class="toc-text">六、UIKit 性能优化 读后总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#首选来说-为什么我们要进行UIKit优化？"><span class="toc-number">6.1.</span> <span class="toc-text">首选来说 为什么我们要进行UIKit优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-为什么要把控件尽量设置成不透明，如果是透明的会有什么影响，如何检测这种影响？"><span class="toc-number">6.2.</span> <span class="toc-text">1.为什么要把控件尽量设置成不透明，如果是透明的会有什么影响，如何检测这种影响？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-离屏渲染"><span class="toc-number">6.3.</span> <span class="toc-text">4.离屏渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-光栅化"><span class="toc-number">6.4.</span> <span class="toc-text">3. 光栅化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-图片大小"><span class="toc-number">7.</span> <span class="toc-text">4.图片大小</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>







    
        <section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'runningyoung'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>
    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/03/07/2016-03-14-Block/" title="上一篇: Block源码解析和深入理解">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2015/06/30/2015-07-08-Iterm2+ZSH-Shell/" title="下一篇: Iterm2+ZSH 打造终极Shell">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/04/06/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/2016-04-05-jenkins2/">iOS持续集成：jenkins+gitlab+蒲公英+邮件通知(Part 2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/2016-04-01-jenkins1/">iOS持续集成：jenkins+gitlab+蒲公英+邮件通知(Part 1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/07/2016-03-14-Block/">Block源码解析和深入理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/2016-03-12-read1/">【iOS读书笔记系列（一）】</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/30/2015-07-08-Iterm2+ZSH-Shell/">Iterm2+ZSH 打造终极Shell</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/30/2015-06-30-iOS-9-AppThinning/">iOS 9 App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/30/2015-07-20-ReactiveCocoa/">ReactiveCocoa 学习之路(史上最全攻略)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/30/2015-08-04-dependency-injection/">关于IOS依赖注入(DI)那些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/06/30/2015-11-20-(BDD)calabash和cucumber/">BDD开发 calabash 和 cucumber的使用</a></li></ul>




    <script>
        
    </script>
</div>
      
<footer id="footer">
    <div class="outer">

        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 RunningYoung
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/RunningYoung/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a> by runningyoung
            </div>
        </div>
        
        

            <div class="visit">
              
                
              </script>
                    <span id="busuanzi_container_site_pv" style='display:none' >
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none' >
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 12;
                var backgroundimg = "url(https://runningyoung.github.io/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-64735170-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>